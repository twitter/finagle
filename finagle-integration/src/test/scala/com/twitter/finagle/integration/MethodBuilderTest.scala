package com.twitter.finagle.integration

import com.twitter.conversions.DurationOps._
import com.twitter.finagle.client.MethodBuilder
import com.twitter.finagle.client.StackClient
import com.twitter.finagle.memcached.protocol.NoOp
import com.twitter.finagle.memcached.protocol.Quit
import com.twitter.finagle.server.StackServer
import com.twitter.finagle.util.DefaultTimer
import com.twitter.finagle.mux
import com.twitter.finagle._
import com.twitter.finagle.service.TimeoutFilter.PropagateDeadlines
import com.twitter.util.Closable.close
import com.twitter.util.{Await, Closable, Future}

import java.net.InetSocketAddress
import org.scalatest.funsuite.AnyFunSuite

import java.util.concurrent.atomic.AtomicBoolean

class MethodBuilderTest extends AnyFunSuite {

  private def await[T](f: Future[T]): T = Await.result(f, 15.seconds)

  private implicit val timer = DefaultTimer
  private val serviceSleep = 50.milliseconds

  private[this] def mkService[Req, Rep](rep: Rep): Service[Req, Rep] = {
    new Service[Req, Rep] {
      def apply(req: Req): Future[Rep] =
        Future.sleep(serviceSleep).before { Future.value(rep) }
    }
  }

  private def testTotalTimeout[Req, Rep](
    name: String,
    stackServer: StackServer[Req, Rep],
    stackClient: StackClient[Req, Rep],
    req: Req,
    rep: Rep
  ): Unit = if (!sys.props.contains("SKIP_FLAKY")) {
    test(s"$name client can use total method builder timeouts") {
      val server = stackServer.serve("localhost:*", mkService(rep))
      val addr = server.boundAddress.asInstanceOf[InetSocketAddress]

      val methodBuilder = MethodBuilder.from(s"${addr.getHostName}:${addr.getPort}", stackClient)

      val short = methodBuilder.withTimeout.total(10.millis).newService("short")
      val long = methodBuilder.withTimeout.total(5.seconds).newService("long")

      // check we get a timeout for a client with a short timeout
      intercept[GlobalRequestTimeoutException] {
        await(short(req))
      }

      // check we get a response for a client with a long timeout
      await(long(req))

      val shortClose = short.close()
      await(long.close())
      await(shortClose)
      await(server.close())
    }
  }

  testTotalTimeout(
    "HTTP/1.1",
    Http.server,
    Http.client,
    http.Request(),
    http.Response()
  )

  testTotalTimeout(
    "HTTP/2",
    Http.server.withHttp2,
    Http.client.withHttp2,
    http.Request(),
    http.Response()
  )

  testTotalTimeout(
    "Memcached",
    Memcached.server,
    Memcached.client,
    Quit(),
    NoOp
  )

  testTotalTimeout(
    "Mux",
    Mux.server,
    Mux.client.withSessionQualifier.noFailFast, // we disable failfast to allow retries to
    mux.Request.empty, // smooth over the race with the server bind.
    mux.Response.empty
  )

  private def testPerRequestTimeout[Req, Rep](
    name: String,
    stackServer: StackServer[Req, Rep],
    stackClient: StackClient[Req, Rep],
    req: Req,
    rep: Rep
  ): Unit = if (!sys.props.contains("SKIP_FLAKY")) {
    test(s"$name client can use per request method builder timeouts") {
      val server = stackServer.serve("localhost:*", mkService(rep))
      val addr = server.boundAddress.asInstanceOf[InetSocketAddress]

      val methodBuilder = MethodBuilder.from(s"${addr.getHostName}:${addr.getPort}", stackClient)

      val short = methodBuilder.withTimeout.perRequest(5.millis).newService("short")
      val long = methodBuilder.withTimeout.perRequest(5.seconds).newService("long")

      // check we get a timeout for a client with a short timeout
      intercept[IndividualRequestTimeoutException] {
        await(short(req))
      }

      // check we get a response for a client with a long timeout
      await(long(req))

      val shortClose = short.close()
      await(long.close())
      await(shortClose)
      await(server.close())
    }
  }

  testPerRequestTimeout(
    "HTTP/1.1",
    Http.server,
    Http.client,
    http.Request(),
    http.Response()
  )

  testPerRequestTimeout(
    "HTTP/2",
    Http.server.withHttp2,
    Http.client.withHttp2,
    http.Request(),
    http.Response()
  )

  testPerRequestTimeout(
    "Memcached",
    Memcached.server,
    Memcached.client,
    Quit(),
    NoOp
  )

  testPerRequestTimeout(
    "Mux",
    Mux.server,
    Mux.client,
    mux.Request.empty,
    mux.Response.empty
  )

  test("Methodbuilder client does not propagate Deadlines") {
    val deadlinePresent = new AtomicBoolean(true)
    val service = Service.mk { request: http.Request =>
      deadlinePresent.set(request.headerMap.get("Finagle-Ctx-com.twitter.finagle.Deadline").isDefined)
      Future.value(http.Response())
    }

    val server = Http.server
      .serve("localhost:*", service)
    val addr = server.boundAddress.asInstanceOf[InetSocketAddress]

    val noPropagationClient = Http.client
      .withLabel("backend-noprop")
      .configured(PropagateDeadlines(false).mk())
      .methodBuilder(s"${addr.getHostName}:${addr.getPort}")
      .newService

    val defaultClient = Http.client
      .withLabel("backend")
      .methodBuilder(s"${addr.getHostName}:${addr.getPort}")
      .newService

    await(noPropagationClient(http.Request("/")))
    assert(!deadlinePresent.get())
    await(defaultClient(http.Request("/")))
    assert(deadlinePresent.get())

    await(server.close())
    await(noPropagationClient.close())
    await(defaultClient.close())
  }

}
