#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#


module FinagleThrift
    module AnnotationType
      BOOL = 0
      BYTES = 1
      I16 = 2
      I32 = 3
      I64 = 4
      DOUBLE = 5
      STRING = 6
      VALUE_MAP = {0 => "BOOL", 1 => "BYTES", 2 => "I16", 3 => "I32", 4 => "I64", 5 => "DOUBLE", 6 => "STRING"}
      VALID_VALUES = Set.new([BOOL, BYTES, I16, I32, I64, DOUBLE, STRING]).freeze
    end

    class Endpoint
      include ::Thrift::Struct, ::Thrift::Struct_Union
      IPV4 = 1
      PORT = 2
      SERVICE_NAME = 3

      FIELDS = {
        IPV4 => {:type => ::Thrift::Types::I32, :name => 'ipv4'},
        PORT => {:type => ::Thrift::Types::I16, :name => 'port'},
        SERVICE_NAME => {:type => ::Thrift::Types::STRING, :name => 'service_name'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Annotation
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TIMESTAMP = 1
      VALUE = 2
      HOST = 3
      DURATION = 4

      FIELDS = {
        TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
        VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'},
        HOST => {:type => ::Thrift::Types::STRUCT, :name => 'host', :class => FinagleThrift::Endpoint, :optional => true},
        DURATION => {:type => ::Thrift::Types::I32, :name => 'duration', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BinaryAnnotation
      include ::Thrift::Struct, ::Thrift::Struct_Union
      KEY = 1
      VALUE = 2
      ANNOTATION_TYPE = 3
      HOST = 4

      FIELDS = {
        KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
        VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :binary => true},
        ANNOTATION_TYPE => {:type => ::Thrift::Types::I32, :name => 'annotation_type', :enum_class => FinagleThrift::AnnotationType},
        HOST => {:type => ::Thrift::Types::STRUCT, :name => 'host', :class => FinagleThrift::Endpoint, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        unless @annotation_type.nil? || FinagleThrift::AnnotationType::VALID_VALUES.include?(@annotation_type)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field annotation_type!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Span
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TRACE_ID = 1
      NAME = 3
      ID = 4
      PARENT_ID = 5
      ANNOTATIONS = 6
      BINARY_ANNOTATIONS = 8
      DEBUG = 9

      FIELDS = {
        TRACE_ID => {:type => ::Thrift::Types::I64, :name => 'trace_id'},
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
        ID => {:type => ::Thrift::Types::I64, :name => 'id'},
        PARENT_ID => {:type => ::Thrift::Types::I64, :name => 'parent_id', :optional => true},
        ANNOTATIONS => {:type => ::Thrift::Types::LIST, :name => 'annotations', :element => {:type => ::Thrift::Types::STRUCT, :class => FinagleThrift::Annotation}},
        BINARY_ANNOTATIONS => {:type => ::Thrift::Types::LIST, :name => 'binary_annotations', :element => {:type => ::Thrift::Types::STRUCT, :class => FinagleThrift::BinaryAnnotation}},
        DEBUG => {:type => ::Thrift::Types::BOOL, :name => 'debug'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # At connection time, we can let the server know who we are so
    # they can book keep and optionally reject unknown clients.
    class ClientId
      include ::Thrift::Struct, ::Thrift::Struct_Union
      NAME = 1

      FIELDS = {
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # This struct serializes com.twitter.finagle.Context
    class RequestContext
      include ::Thrift::Struct, ::Thrift::Struct_Union
      KEY = 1
      VALUE = 2

      FIELDS = {
        KEY => {:type => ::Thrift::Types::STRING, :name => 'key', :binary => true},
        VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :binary => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # Serializes an individual delegation.
    class Delegation
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SRC = 1
      DST = 2

      FIELDS = {
        SRC => {:type => ::Thrift::Types::STRING, :name => 'src'},
        DST => {:type => ::Thrift::Types::STRING, :name => 'dst'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # RequestHeader defines headers for the request. These carry the span data, and
    # a flag indicating whether the request is to be debugged.
    class RequestHeader
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TRACE_ID = 1
      SPAN_ID = 2
      PARENT_SPAN_ID = 3
      SAMPLED = 5
      CLIENT_ID = 6
      FLAGS = 7
      CONTEXTS = 8
      DEST = 9
      DELEGATIONS = 10

      FIELDS = {
        TRACE_ID => {:type => ::Thrift::Types::I64, :name => 'trace_id'},
        SPAN_ID => {:type => ::Thrift::Types::I64, :name => 'span_id'},
        PARENT_SPAN_ID => {:type => ::Thrift::Types::I64, :name => 'parent_span_id', :optional => true},
        SAMPLED => {:type => ::Thrift::Types::BOOL, :name => 'sampled', :optional => true},
        CLIENT_ID => {:type => ::Thrift::Types::STRUCT, :name => 'client_id', :class => FinagleThrift::ClientId, :optional => true},
        FLAGS => {:type => ::Thrift::Types::I64, :name => 'flags', :optional => true},
        CONTEXTS => {:type => ::Thrift::Types::LIST, :name => 'contexts', :element => {:type => ::Thrift::Types::STRUCT, :class => FinagleThrift::RequestContext}},
        DEST => {:type => ::Thrift::Types::STRING, :name => 'dest', :optional => true},
        DELEGATIONS => {:type => ::Thrift::Types::LIST, :name => 'delegations', :element => {:type => ::Thrift::Types::STRUCT, :class => FinagleThrift::Delegation}, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # The Response carries a reply header for tracing. These are
    # empty unless the request is being debugged, in which case a
    # transcript is copied.
    class ResponseHeader
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SPANS = 1
      CONTEXTS = 2

      FIELDS = {
        SPANS => {:type => ::Thrift::Types::LIST, :name => 'spans', :element => {:type => ::Thrift::Types::STRUCT, :class => FinagleThrift::Span}},
        CONTEXTS => {:type => ::Thrift::Types::LIST, :name => 'contexts', :element => {:type => ::Thrift::Types::STRUCT, :class => FinagleThrift::RequestContext}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # These are connection-level options negotiated during protocol
    # upgrade.
    class ConnectionOptions
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # This is the struct that a successful upgrade will reply with.
    class UpgradeReply
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

  end
