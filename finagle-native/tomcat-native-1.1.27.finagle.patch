diff --git a/jni/build.properties.default b/jni/build.properties.default
index 663b19a..8c90e1c 100644
--- a/jni/build.properties.default
+++ b/jni/build.properties.default
@@ -33,7 +33,7 @@ base.path=/usr/share/java
 
 compile.source=1.7
 compile.target=1.7
-compile.debug=off
+compile.debug=on
 compile.deprecation=on
 compile.optimize=on
 
diff --git a/jni/java/org/apache/tomcat/jni/SSL.java b/jni/java/org/apache/tomcat/jni/SSL.java
index 2aa91e0..275a4d6 100644
--- a/jni/java/org/apache/tomcat/jni/SSL.java
+++ b/jni/java/org/apache/tomcat/jni/SSL.java
@@ -16,6 +16,8 @@
  */
 package org.apache.tomcat.jni;
 
+import java.nio.ByteBuffer;
+
 /** SSL
  *
  * @author Mladen Turk
@@ -136,6 +138,8 @@ public final class SSL {
     public static final int SSL_OP_NO_SSLv2                         = 0x01000000;
     public static final int SSL_OP_NO_SSLv3                         = 0x02000000;
     public static final int SSL_OP_NO_TLSv1                         = 0x04000000;
+    public static final int SSL_OP_NO_TLSv1_1                       = 0x10000000;
+    public static final int SSL_OP_NO_TLSv1_2                       = 0x08000000;
     public static final int SSL_OP_NO_TICKET                        = 0x00004000;
 
     /* The next flag deliberately changes the ciphertest, this is a check
@@ -352,4 +356,184 @@ public final class SSL {
      * @return true if all SSL_OP_* are supported by OpenSSL library.
      */
     public static native boolean hasOp(int op);
+
+    /*
+     * Begin Twitter API additions
+     */
+
+    public static final int SSL_SENT_SHUTDOWN = 1;
+    public static final int SSL_RECEIVED_SHUTDOWN = 2;
+
+    public static final int SSL_ERROR_NONE             = 0;
+    public static final int SSL_ERROR_SSL              = 1;
+    public static final int SSL_ERROR_WANT_READ        = 2;
+    public static final int SSL_ERROR_WANT_WRITE       = 3;
+    public static final int SSL_ERROR_WANT_X509_LOOKUP = 4;
+    public static final int SSL_ERROR_SYSCALL          = 5; /* look at error stack/return value/errno */
+    public static final int SSL_ERROR_ZERO_RETURN      = 6;
+    public static final int SSL_ERROR_WANT_CONNECT     = 7;
+    public static final int SSL_ERROR_WANT_ACCEPT      = 8;
+
+    /**
+     * SSL_new
+     * @param ctx Server or Client context to use.
+     * @param server if true configure SSL instance to use accept handshake routines
+     *               if false configure SSL instance to use connect handshake routines
+     * @return pointer to SSL instance (SSL *)
+     */
+    public static native long newSSL(long ctx, boolean server);
+
+    /**
+     * SSL_set_bio
+     * @param ssl SSL pointer (SSL *)
+     * @param rbio read BIO pointer (BIO *)
+     * @param wbio write BIO pointer (BIO *)
+     */
+    public static native void setBIO(long ssl, long rbio, long wbio);
+
+    /**
+     * SSL_get_error
+     * @param ssl SSL pointer (SSL *)
+     * @param ret TLS/SSL I/O return value
+     */
+    public static native int getError(long ssl, int ret);
+
+    /**
+     * BIO_ctrl_pending
+     * @param bio BIO pointer (BIO *)
+     * @return
+     */
+    public static native int pendingWrittenBytesInBIO(long bio);
+
+    /**
+     * SSL_pending
+     * @param ssl SSL pointer (SSL *)
+     * @return
+     */
+    public static native int pendingReadableBytesInSSL(long ssl);
+
+    /**
+     * BIO_write
+     * @param bio
+     * @param wbuf
+     * @param wlen
+     * @return
+     */
+    public static native int writeToBIO(long bio, long wbuf, int wlen);
+
+    /**
+     * BIO_read
+     * @param bio
+     * @param rbuf
+     * @param rlen
+     * @return
+     */
+    public static native int readFromBIO(long bio, long rbuf, int rlen);
+
+    /**
+     * SSL_write
+     * @param ssl the SSL instance (SSL *)
+     * @param wbuf
+     * @param wlen
+     * @return
+     */
+    public static native int writeToSSL(long ssl, long wbuf, int wlen);
+
+    /**
+     * SSL_read
+     * @param ssl the SSL instance (SSL *)
+     * @param rbuf
+     * @param rlen
+     * @return
+     */
+    public static native int readFromSSL(long ssl, long rbuf, int rlen);
+
+    /**
+     * SSL_get_shutdown
+     * @param ssl the SSL instance (SSL *)
+     * @return
+     */
+    public static native int getShutdown(long ssl);
+
+    /**
+     * SSL_set_shutdown
+     * @param ssl the SSL instance (SSL *)
+     * @param mode
+     */
+    public static native void setShutdown(long ssl, int mode);
+
+    /**
+     * SSL_free
+     * @param ssl the SSL instance (SSL *)
+     */
+    public static native void freeSSL(long ssl);
+
+    /**
+     * Wire up internal and network BIOs for the given SSL instance.
+     *
+     * <b>Warning: you must explicitly free this resource by calling freeBIO</b>
+     *
+     * While the SSL's internal/application data BIO will be freed when freeSSL is called on
+     * the provided SSL instance, you must call freeBIO on the returned network BIO.
+     *
+     * @param ssl the SSL instance (SSL *)
+     * @return pointer to the Network BIO (BIO *)
+     */
+    public static native long makeNetworkBIO(long ssl);
+
+    /**
+     * BIO_free
+     * @param bio
+     */
+    public static native void freeBIO(long bio);
+
+    /**
+     * BIO_flush
+     * @param bio
+     */
+    public static native void flushBIO(long bio);
+
+    /**
+     * SSL_shutdown
+     * @param ssl the SSL instance (SSL *)
+     * @return
+     */
+    public static native int shutdownSSL(long ssl);
+
+    /**
+     * Get the error number representing the last error OpenSSL encountered on this thread.
+     * @return
+     */
+    public static native int getLastErrorNumber();
+
+    /**
+     * SSL_get_cipher
+     * @param ssl the SSL instance (SSL *)
+     * @return
+     */
+    public static native String getCipherForSSL(long ssl);
+
+    /**
+     * SSL_do_handshake
+     * @param ssl the SSL instance (SSL *)
+     */
+    public static native int doHandshake(long ssl);
+
+    /**
+     * SSL_in_init
+     * @param SSL
+     * @return
+     */
+    public static native int isInInit(long SSL);
+
+    /**
+     * SSL_get0_next_proto_negotiated
+     * @param ssl the SSL isntance (SSL *)
+     * @return
+     */
+    public static native String getNextProtoNegotiated(long ssl);
+
+    /*
+     * End Twitter API Additions
+     */
 }
diff --git a/jni/java/org/apache/tomcat/jni/SSLContext.java b/jni/java/org/apache/tomcat/jni/SSLContext.java
index d294306..05b8a81 100644
--- a/jni/java/org/apache/tomcat/jni/SSLContext.java
+++ b/jni/java/org/apache/tomcat/jni/SSLContext.java
@@ -208,6 +208,40 @@ public final class SSLContext {
         throws Exception;
 
     /**
+     * Set the size of the internal session cache.
+     * http://www.openssl.org/docs/ssl/SSL_CTX_sess_set_cache_size.html
+     */
+    public static native long setSessionCacheSize(long ctx, long size);
+
+    /**
+     * Set the timeout for the internal session cache in seconds.
+     * http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html
+     */
+    public static native long setSessionCacheTimeout(long ctx, long timeoutSeconds);
+
+    /**
+     * Session resumption statistics methods.
+     * http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html
+     */
+    public static native long sessionAccept(long ctx);
+    public static native long sessionAcceptGood(long ctx);
+    public static native long sessionAcceptRenegotiate(long ctx);
+    public static native long sessionCacheFull(long ctx);
+    public static native long sessionCbHits(long ctx);
+    public static native long sessionConnect(long ctx);
+    public static native long sessionConnectGood(long ctx);
+    public static native long sessionConnectRenegotiate(long ctx);
+    public static native long sessionHits(long ctx);
+    public static native long sessionMisses(long ctx);
+    public static native long sessionNumber(long ctx);
+    public static native long sessionTimeouts(long ctx);
+
+    /**
+     * Set TLS session keys. This allows us to share keys across TFEs.
+     */
+    public static native void setSessionTicketKeys(long ctx, byte[] keys);
+
+    /**
      * Set File and Directory of concatenated PEM-encoded CA Certificates
      * for Client Auth
      * <br />
@@ -288,4 +322,10 @@ public final class SSLContext {
      */
     public static native void setVerify(long ctx, int level, int depth);
 
+    /**
+     * Set next protocol for next protocol negotiation extension
+     * @param ctx Server context to use.
+     * @param next_protos comma deliniated list of protocols in priority order
+     */
+    public static native void setNextProtos(long ctx, String next_protos);
 }
diff --git a/jni/java/org/apache/tomcat/jni/ssl/DirectBufferOperation.java b/jni/java/org/apache/tomcat/jni/ssl/DirectBufferOperation.java
new file mode 100644
index 0000000..a7278d4
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/DirectBufferOperation.java
@@ -0,0 +1,39 @@
+package org.apache.tomcat.jni.ssl;
+
+import org.apache.tomcat.jni.Buffer;
+
+import java.nio.ByteBuffer;
+
+abstract class DirectBufferOperation {
+    private final static RuntimeException ALLOCATION_INTERRUPTED =
+        new IllegalStateException("Buffer allocation interrupted");
+
+    private DirectBufferPool pool;
+
+    public DirectBufferOperation(DirectBufferPool pool) {
+        this.pool = pool;
+
+        ByteBuffer buffer = acquireDirectBuffer();
+        try {
+            run(buffer, Buffer.address(buffer));
+        } finally {
+            releaseDirectBuffer(buffer);
+        }
+    }
+
+    private ByteBuffer acquireDirectBuffer() {
+        try {
+            return pool.acquire();
+        } catch (InterruptedException e) {
+            throw ALLOCATION_INTERRUPTED;
+        }
+    }
+
+    private void releaseDirectBuffer(ByteBuffer buffer) {
+        buffer.rewind();
+        buffer.clear();
+        pool.release(buffer);
+    }
+
+    abstract void run(ByteBuffer buffer, long address);
+}
diff --git a/jni/java/org/apache/tomcat/jni/ssl/DirectBufferPool.java b/jni/java/org/apache/tomcat/jni/ssl/DirectBufferPool.java
new file mode 100644
index 0000000..413ac51
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/DirectBufferPool.java
@@ -0,0 +1,67 @@
+package org.apache.tomcat.jni.ssl;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Manages a pool of directly-allocated ByteBuffers.
+ *
+ * This is necessary as the reclamation of these buffers does not work appropriately
+ * on some platforms.
+ *
+ * TODO: Attempt to replace the directly-allocated ByteBuffers this with one APR pool.
+ */
+public class DirectBufferPool {
+    private LinkedBlockingQueue<ByteBuffer> buffers;
+
+    // BUFFER_SIZE must be large enough to accomodate the maximum SSL record size.
+    // Header (5) + Data (2^14) + Compression (1024) + Encryption (1024) + MAC (20) + Padding (256)
+    private final int BUFFER_SIZE = 18713;
+
+    /**
+     * Construct a new pool with the specified capacity.
+     *
+     * @param capacity The number of buffers to instantiate.
+     */
+    public DirectBufferPool(int capacity) {
+        buffers = new LinkedBlockingQueue<ByteBuffer>(capacity);
+        while (buffers.remainingCapacity() > 0) {
+            ByteBuffer buf = ByteBuffer.allocateDirect(BUFFER_SIZE);
+
+            buf.order(ByteOrder.nativeOrder());
+
+            buffers.offer(buf);
+        }
+    }
+
+    /**
+     * Take a buffer from the pool.
+     *
+     * @returns a ByteBuffer.
+     */
+    public ByteBuffer acquire() throws InterruptedException {
+        return buffers.take();
+    }
+
+    /**
+     * Release a buffer back into the stream
+     *
+     * @param buffer the ByteBuffer to release
+     */
+    public void release(ByteBuffer buffer) {
+        buffer.clear();
+        buffers.offer(buffer);
+    }
+
+    @Override
+    public String toString() {
+        return "[DirectBufferPool " +
+            buffers.size() + " buffers * " +
+            BUFFER_SIZE + " bytes = " +
+            buffers.size() * BUFFER_SIZE + " total bytes; " +
+            "size: " + buffers.size() +
+            " remainingCapacity: " + buffers.remainingCapacity() +
+            "]";
+    }
+}
diff --git a/jni/java/org/apache/tomcat/jni/ssl/OpenSSLEngine.java b/jni/java/org/apache/tomcat/jni/ssl/OpenSSLEngine.java
new file mode 100644
index 0000000..051c266
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/OpenSSLEngine.java
@@ -0,0 +1,711 @@
+package org.apache.tomcat.jni.ssl;
+
+import org.apache.tomcat.jni.SSL;
+
+import javax.net.ssl.*;
+import javax.security.cert.X509Certificate;
+import java.nio.ByteBuffer;
+import java.nio.ReadOnlyBufferException;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Implements a java.net.SSLEngine in terms of OpenSSL.
+ *
+ * Documentation on the dataflow and operation of SSLEngine and OpenSSL BIO abstractions
+ * can be found at:
+ *
+ *   SSLEngine: http://download.oracle.com/javase/1,5.0/docs/api/javax/net/ssl/SSLEngine.html
+ *   OpenSSL:   http://www.openssl.org/docs/crypto/BIO_s_bio.html#example
+ */
+public class OpenSSLEngine extends javax.net.ssl.SSLEngine {
+    private static final Logger LOG = Logger.getLogger(OpenSSLEngine.class.getName());
+
+    private static SSLException ENGINE_IS_CLOSED = new SSLException("Engine is closed");
+    private static SSLException RENEGOTIATION_NOT_SUPPORTED = new SSLException("Renegotiation is not supported");
+    private static SSLException ENCRYPTED_PACKET_OVERSIZE = new SSLException("Encrypted packet is oversize");
+
+    private static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14
+    private static final int MAX_COMPRESSED_LENGTH = MAX_PLAINTEXT_LENGTH + 1024;
+    private static final int MAX_CIPHERTEXT_LENGTH = MAX_COMPRESSED_LENGTH + 1024;
+    private static final int MAX_ENCRYPTED_PACKET = MAX_CIPHERTEXT_LENGTH + 5 + 20 + 256;
+
+    private static final String SSL_IGNORABLE_ERROR_PREFIX = "error:00000000:";
+
+    // OpenSSL state
+    private long ssl;
+    private long networkBIO;
+
+    private boolean accepted = false;
+    private boolean handshakeFinished = false;
+    private boolean receivedShutdown = false;
+    private AtomicBoolean destroyed = new AtomicBoolean(false);
+
+    private String cipher = null;
+    private String protocol = null;
+
+    // SSL Engine status variables
+    private boolean isInboundDone = false;
+    private boolean isOutboundDone = false;
+    private boolean engineClosed = false;
+
+    private DirectBufferPool bufferPool;
+
+    public OpenSSLEngine(SSLContextHolder contextHolder, DirectBufferPool bufferPool) {
+        this.bufferPool = bufferPool;
+        this.ssl = SSL.newSSL(contextHolder.getSslContext(), true);
+        this.networkBIO = SSL.makeNetworkBIO(ssl);
+    }
+
+    public synchronized void shutdown() {
+        if (destroyed.compareAndSet(false, true)) {
+            SSL.freeSSL(ssl);
+            SSL.freeBIO(networkBIO);
+            ssl = networkBIO = 0;
+
+            // internal errors can cause shutdown without marking the engine closed
+            isInboundDone = isOutboundDone = engineClosed = true;
+        }
+    }
+
+    /**
+     * Write plaintext data to the OpenSSL internal BIO
+     *
+     * Calling this function with src.remaining == 0 is undefined.
+     */
+    private int writePlaintextData(final ByteBuffer src) {
+        final AtomicInteger written = new AtomicInteger(0);
+        new DirectBufferOperation(bufferPool) {
+            @Override
+            void run(ByteBuffer buffer, long address) {
+                int position = src.position();
+                int limit = src.limit();
+                int len = Math.min(src.remaining(), MAX_PLAINTEXT_LENGTH);
+                if (len > buffer.capacity())
+                    throw new RuntimeException("Buffer pool write overflow");
+                src.limit(position + len);
+
+                buffer.put(src);
+                src.limit(limit);
+                int sslWrote = SSL.writeToSSL(ssl, address, len);
+                if (sslWrote > 0) {
+                    src.position(position + sslWrote);
+                    written.set(sslWrote);
+                } else {
+                    src.position(position);
+                    throw new IllegalStateException();
+                }
+            }
+        };
+        return written.get();
+    }
+
+    /**
+     * Write encrypted data to the OpenSSL network BIO
+     */
+    private int writeEncryptedData(final ByteBuffer src, final AtomicInteger primingReadResult) {
+        final AtomicInteger written = new AtomicInteger(0);
+        new DirectBufferOperation(bufferPool) {
+            @Override
+            void run(ByteBuffer buffer, long address) {
+                int position = src.position();
+                int len = src.remaining();
+                if (len > buffer.capacity())
+                    throw new RuntimeException("Buffer pool write overflow");
+
+                buffer.put(src);
+                int netWrote = SSL.writeToBIO(networkBIO, address, len);
+                if (netWrote > -1) {
+                    written.set(netWrote);
+                    src.position(position + netWrote);
+                    primingReadResult.set(SSL.readFromSSL(ssl, address, 0)); // priming read
+                } else {
+                    src.position(position);
+                }
+            }
+        };
+        return written.get();
+    }
+
+    /**
+     * Read plaintext data from the OpenSSL internal BIO
+     */
+    private int readPlaintextData(final ByteBuffer dst) {
+        final AtomicInteger read = new AtomicInteger(0);
+        new DirectBufferOperation(bufferPool) {
+            @Override
+            void run(ByteBuffer buffer, long address) {
+                buffer.limit(Math.min(buffer.limit(), dst.capacity()));
+                int sslRead = SSL.readFromSSL(ssl, address, buffer.limit());
+                if (sslRead > 0) {
+                    read.set(sslRead);
+                    buffer.limit(sslRead);
+                    dst.put(buffer);
+                }
+            }
+        };
+        return read.get();
+    }
+
+    /**
+     * Read encrypted data from the OpenSSL network BIO
+     */
+    private int readEncryptedData(final ByteBuffer dst, final int pending) {
+        final AtomicInteger read = new AtomicInteger(0);
+        new DirectBufferOperation(bufferPool) {
+            @Override
+            void run(ByteBuffer buffer, long address) {
+                if (pending > buffer.capacity())
+                    throw new RuntimeException("Network BIO read overflow (pending=" + pending +
+                                               "; capacity=" + buffer.capacity() + ")");
+
+                int bioRead = SSL.readFromBIO(networkBIO, address, pending);
+                if (bioRead > 0) {
+                    read.set(bioRead);
+                    buffer.limit(bioRead);
+                    dst.put(buffer);
+                }
+            }
+        };
+        return read.get();
+    }
+
+    /**
+     * Encrypt plaintext data from srcs buffers into dst buffer.
+     *
+     * This is called both to encrypt application data as well as
+     * to retrieve handshake data destined for the peer.
+     */
+    @Override
+    public synchronized SSLEngineResult wrap(final ByteBuffer[] srcs,
+                                             final int offset,
+                                             final int length,
+                                             final ByteBuffer dst)
+            throws SSLException {
+
+        int bytesConsumed = 0;
+        int bytesProduced = 0;
+
+        // Check to make sure the engine has not been closed
+        if (destroyed.get()) {
+            return new SSLEngineResult(SSLEngineResult.Status.CLOSED,
+                    SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING,
+                    bytesConsumed,
+                    bytesProduced);
+        }
+
+        // Throw required runtime exceptions
+        if ((null == srcs) || (null == dst)) throw new IllegalArgumentException();
+        if ((offset >= srcs.length) || (offset + length) > srcs.length)
+            throw new IndexOutOfBoundsException();
+        if (dst.isReadOnly())
+            throw new ReadOnlyBufferException();
+
+        // Prepare OpenSSL to work in server mode and receive handshake
+        if (!accepted) beginHandshake();
+
+        // In handshake or close_notify stages, check if call to wrap was made
+        // without regard to the handshake status.
+        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
+        if ((!handshakeFinished || engineClosed) &&
+                handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_UNWRAP))
+            return new SSLEngineResult(getEngineStatus(),
+                    handshakeStatus,
+                    bytesConsumed,
+                    bytesProduced);
+
+        { // Scope pendingNet
+            // Check for pending data in the network BIO
+            int pendingNet = SSL.pendingWrittenBytesInBIO(networkBIO);
+            if (pendingNet > 0) {
+                // Do we have enough room in dst to write encrypted data?
+                int capacity = dst.remaining();
+                if (capacity < pendingNet)
+                    return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,
+                                               handshakeStatus,
+                                               bytesConsumed,
+                                               bytesProduced);
+
+                // Write the pending data from the network BIO into the dst buffer
+                try {
+                    bytesProduced += readEncryptedData(dst, pendingNet);
+                } catch (Exception e) {
+                    throw new SSLException(e);
+                }
+
+                // If isOuboundDone is set, then the data from the network BIO
+                // was the close_notify message -- we are not required to wait
+                // for the receipt the peer's close_notify message -- shutdown.
+                if (isOutboundDone) shutdown();
+
+                return new SSLEngineResult(getEngineStatus(),
+                                           getHandshakeStatus(),
+                                           bytesConsumed,
+                                           bytesProduced);
+            }
+        }
+
+        // There was no pending data in the network BIO -- encrypt any application data
+        for (int i = offset; i < length; ++i) {
+            while (srcs[i].hasRemaining()) {
+
+                // Write plaintext application data to the SSL engine
+                try {
+                    bytesConsumed += writePlaintextData(srcs[i]);
+                } catch (Exception e) {
+                    throw new SSLException(e);
+                }
+
+                // Check to see if the engine wrote data into the network BIO
+                int pendingNet = SSL.pendingWrittenBytesInBIO(networkBIO);
+                if (pendingNet > 0) {
+                    // Do we have enough room in dst to write encrypted data?
+                    int capacity = dst.remaining();
+                    if (capacity < pendingNet)
+                        return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,
+                                getHandshakeStatus(),
+                                bytesConsumed,
+                                bytesProduced);
+
+                    // Write the pending data from the network BIO into the dst buffer
+                    try {
+                        bytesProduced += readEncryptedData(dst, pendingNet);
+                    } catch (Exception e) {
+                        throw new SSLException(e);
+                    }
+
+                    return new SSLEngineResult(getEngineStatus(),
+                            getHandshakeStatus(),
+                            bytesConsumed,
+                            bytesProduced);
+                }
+            }
+        }
+        return new SSLEngineResult(getEngineStatus(),
+                getHandshakeStatus(),
+                bytesConsumed,
+                bytesProduced);
+    }
+
+    /**
+     * Decrypt encrypted data from src buffers into dsts buffers.
+     */
+    @Override
+    public synchronized SSLEngineResult unwrap(final ByteBuffer src,
+                                               final ByteBuffer[] dsts,
+                                               final int offset,
+                                               final int length)
+            throws SSLException {
+
+        int bytesConsumed = 0;
+        int bytesProduced = 0;
+
+        // Check to make sure the engine has not been closed
+        if (destroyed.get()) {
+            return new SSLEngineResult(SSLEngineResult.Status.CLOSED,
+                    SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING,
+                    bytesConsumed,
+                    bytesProduced);
+        }
+
+        // Throw requried runtime exceptions
+        if ((null == src) || (null == dsts)) throw new IllegalArgumentException();
+        if ((offset >= dsts.length) || (offset + length > dsts.length))
+            throw new IndexOutOfBoundsException();
+
+        int capacity = 0;
+        for (int i = offset; i < offset + length; ++i) {
+            if (null == dsts[i]) throw new IllegalArgumentException();
+            if (dsts[i].isReadOnly()) throw new ReadOnlyBufferException();
+            capacity += dsts[i].remaining();
+        }
+
+        // Prepare OpenSSL to work in server mode and receive handshake
+        if (!accepted) beginHandshake();
+
+        // In handshake or close_notify stages, check if call to unwrap was made
+        // without regard to the handshake status.
+        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
+        if ((!handshakeFinished || engineClosed) &&
+                handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_WRAP))
+            return new SSLEngineResult(getEngineStatus(),
+                    handshakeStatus,
+                    bytesConsumed,
+                    bytesProduced);
+
+        // protect against protocol overflow attack vector
+        if (src.remaining() > MAX_ENCRYPTED_PACKET) {
+            isInboundDone = true;
+            isOutboundDone = true;
+            engineClosed = true;
+            shutdown();
+            throw ENCRYPTED_PACKET_OVERSIZE;
+        }
+
+        // Write encrypted data to network BIO
+        AtomicInteger primingReadResult = new AtomicInteger(0);
+        try {
+            bytesConsumed += writeEncryptedData(src, primingReadResult);
+        } catch (Exception e) {
+            throw new SSLException(e);
+        }
+
+        // Check for OpenSSL errors caused by the priming read
+        String error = SSL.getLastError();
+        if (error != null && !error.startsWith(SSL_IGNORABLE_ERROR_PREFIX)) {
+            if (LOG.isLoggable(Level.INFO))
+                LOG.info("SSL_read failed: primingReadResult: " + primingReadResult.get() +
+                         "; OpenSSL error: '" + error + "'");
+
+            // There was an internal error -- shutdown
+            shutdown();
+            throw new SSLException(error);
+        }
+
+        // There won't be any application data until we're done handshaking
+        int pendingApp = (SSL.isInInit(ssl) == 0) ? SSL.pendingReadableBytesInSSL(ssl) : 0;
+
+        // Do we have enough room in dsts to write decrypted data?
+        if (capacity < pendingApp)
+          return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,
+                                     getHandshakeStatus(),
+                                     bytesConsumed,
+                                     bytesProduced);
+
+        // Write decrypted data to dsts buffers
+        int idx = offset;
+        while (pendingApp > 0) {
+          while (dsts[idx].capacity() == 0) {
+            ++idx;
+          }
+
+          int bytesRead = 0;
+          try {
+              bytesRead = readPlaintextData(dsts[idx]);
+          } catch (Exception e) {
+              throw new SSLException(e);
+          }
+
+          if (bytesRead == 0) break;
+          bytesProduced += bytesRead;
+          pendingApp -= bytesRead;
+          if (dsts[idx].remaining() == 0) ++idx;
+        }
+
+        // Check to see if we received a close_notify message from the peer
+        if (!receivedShutdown && ((SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN)) {
+            receivedShutdown = true;
+            closeOutbound();
+            closeInbound();
+        }
+
+        return new SSLEngineResult(getEngineStatus(),
+                getHandshakeStatus(),
+                bytesConsumed,
+                bytesProduced);
+    }
+
+    /**
+     * Currently we do not delegate SSL computation tasks
+     * todo: in the future, possibly create tasks to do encrypt / decrypt async
+     */
+    @Override
+    public Runnable getDelegatedTask() {
+        return null;
+    }
+
+    /**
+     * This method is called on channel disconnection by SSLHandler when the server
+     * did not initiate the closure process to detect against truncation attacks.
+     */
+    @Override
+    public synchronized void closeInbound() throws SSLException {
+        if (isInboundDone) return;
+        isInboundDone = true;
+        engineClosed = true;
+        if (accepted) {
+            if (!receivedShutdown) {
+                shutdown();
+                throw new SSLException("close_notify has not been received");
+            }
+        } else {
+            // engine closing before initial handshake
+            shutdown();
+        }
+    }
+
+    @Override
+    public synchronized boolean isInboundDone() {
+        return isInboundDone || engineClosed;
+    }
+
+    /**
+     * This method is called on channel disconnection to send close_notify
+     */
+    @Override
+    public synchronized void closeOutbound() {
+        if (isOutboundDone) return;
+        isOutboundDone = true;
+        engineClosed = true;
+        if (accepted && !destroyed.get()) {
+            int mode = SSL.getShutdown(ssl);
+            if ((mode & SSL.SSL_SENT_SHUTDOWN) != SSL.SSL_SENT_SHUTDOWN)
+                SSL.shutdownSSL(ssl);
+        } else {
+            // engine closing before initial handshake
+            shutdown();
+        }
+    }
+
+    @Override
+    public synchronized boolean isOutboundDone() {
+        return isOutboundDone;
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        return new String[0];
+    }
+
+    @Override
+    public String[] getEnabledCipherSuites() {
+        return new String[0];
+    }
+
+    @Override
+    public void setEnabledCipherSuites(String[] strings) {
+    }
+
+    @Override
+    public String[] getSupportedProtocols() {
+        return new String[0];
+    }
+
+    @Override
+    public String[] getEnabledProtocols() {
+        return new String[0];
+    }
+
+    @Override
+    public void setEnabledProtocols(String[] strings) {
+    }
+
+    @Override
+    public SSLSession getSession() {
+        return new SSLSession() {
+            @Override
+            public byte[] getId() {
+               return String.valueOf(ssl).getBytes();
+            }
+
+            @Override
+            public SSLSessionContext getSessionContext() {
+                return null;
+            }
+
+            @Override
+            public long getCreationTime() {
+                return 0;
+            }
+
+            @Override
+            public long getLastAccessedTime() {
+                return 0;
+            }
+
+            @Override
+            public void invalidate() {
+
+            }
+
+            @Override
+            public boolean isValid() {
+                return false;
+            }
+
+            @Override
+            public void putValue(String s, Object o) {
+
+            }
+
+            @Override
+            public Object getValue(String s) {
+                return null;
+            }
+
+            @Override
+            public void removeValue(String s) {
+
+            }
+
+            @Override
+            public String[] getValueNames() {
+                return new String[0];
+            }
+
+            @Override
+            public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
+                return new Certificate[0];
+            }
+
+            @Override
+            public Certificate[] getLocalCertificates() {
+                return new Certificate[0];
+            }
+
+            @Override
+            public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
+                return new X509Certificate[0];
+            }
+
+            @Override
+            public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+                return null;
+            }
+
+            @Override
+            public Principal getLocalPrincipal() {
+                return null;
+            }
+
+            @Override
+            public String getCipherSuite() {
+                return cipher;
+            }
+
+            @Override
+            public String getProtocol() {
+                return protocol;
+            }
+
+            @Override
+            public String getPeerHost() {
+                return null;
+            }
+
+            @Override
+            public int getPeerPort() {
+                return 0;
+            }
+
+            @Override
+            public int getPacketBufferSize() {
+                return MAX_ENCRYPTED_PACKET;
+            }
+
+            @Override
+            public int getApplicationBufferSize() {
+                return MAX_PLAINTEXT_LENGTH;
+            }
+        };
+    }
+
+    /**
+     * This method causes the OpenSSL engine to accept connections
+     */
+    @Override
+    public synchronized void beginHandshake() throws SSLException {
+        if (engineClosed) throw ENGINE_IS_CLOSED;
+        if (!accepted) {
+            SSL.doHandshake(ssl);
+            accepted = true;
+        } else {
+            throw RENEGOTIATION_NOT_SUPPORTED;
+        }
+    }
+
+    private SSLEngineResult.Status getEngineStatus() {
+        if (engineClosed)
+            return SSLEngineResult.Status.CLOSED;
+        return SSLEngineResult.Status.OK;
+    }
+
+    /**
+     * Return the handshake status of the SSL Engine.
+     */
+    @Override
+    public synchronized SSLEngineResult.HandshakeStatus getHandshakeStatus() {
+        if (!accepted || destroyed.get())
+            return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
+
+        // Check if we are in the initial handshake phase
+        if (!handshakeFinished) {
+            // There is pending data in the network BIO -- call wrap
+            if (SSL.pendingWrittenBytesInBIO(networkBIO) != 0)
+               return SSLEngineResult.HandshakeStatus.NEED_WRAP;
+
+            // No pending data to be sent to the peer
+            // Check to see if we have finished handshaking
+            if (SSL.isInInit(ssl) == 0) {
+                handshakeFinished = true;
+                cipher = SSL.getCipherForSSL(ssl);
+                protocol = SSL.getNextProtoNegotiated(ssl);
+                return SSLEngineResult.HandshakeStatus.FINISHED;
+            }
+
+            // No pending data and still handshaking
+            // Must be waiting on the peer to send more data
+            return SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
+        }
+
+        // Check if we are in the shutdown phase
+        if (engineClosed) {
+            // Waiting to send the close_notify message
+            if (SSL.pendingWrittenBytesInBIO(networkBIO) != 0)
+                return SSLEngineResult.HandshakeStatus.NEED_WRAP;
+
+            // Must be waiting to receive the close_notify message
+            return SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
+        }
+
+        return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
+    }
+
+    @Override
+    public void setUseClientMode(boolean clientMode) {
+        if (clientMode)
+            throw new RuntimeException("Client mode is unsupported");
+    }
+
+    @Override
+    public boolean getUseClientMode() {
+        return false;
+    }
+
+    @Override
+    public void setNeedClientAuth(boolean b) {
+    }
+
+    @Override
+    public boolean getNeedClientAuth() {
+        return false;
+    }
+
+    @Override
+    public void setWantClientAuth(boolean b) {
+    }
+
+    @Override
+    public boolean getWantClientAuth() {
+        return false;
+    }
+
+    @Override
+    public void setEnableSessionCreation(boolean b) {
+    }
+
+    @Override
+    public boolean getEnableSessionCreation() {
+        return false;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        shutdown();
+        super.finalize();
+    }
+}
diff --git a/jni/java/org/apache/tomcat/jni/ssl/SSLConfiguration.java b/jni/java/org/apache/tomcat/jni/ssl/SSLConfiguration.java
new file mode 100644
index 0000000..1997d42
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/SSLConfiguration.java
@@ -0,0 +1,155 @@
+package org.apache.tomcat.jni.ssl;
+
+import java.util.Map;
+
+/**
+ * Encapsulates the configuration parameters necessary for the construction of a SSLContextHolder.
+ */
+public class SSLConfiguration {
+    /**
+     * Thrown when required fields have not been assigned in a SSLConfiguration.
+     */
+    public class IncompleteConfiguration extends Exception {
+        public IncompleteConfiguration(String message) {
+            super(message);
+        }
+    }
+
+    public static final String CERT_PATH = "ssl.cert_path";
+    public static final String KEY_PATH = "ssl.key_path";
+    public static final String CIPHER_SPEC = "ssl.cipher_spec";
+    public static final String KEY_PASSWORD = "ssl.key_password";
+    public static final String CA_PATH = "ssl.ca_path";
+    public static final String NEXT_PROTOS = "ssl.next_protos";
+
+    private String certPath = null;
+    private String keyPath = null;
+    private String cipherSpec = null;
+    private String keyPassword = null;
+    private String caPath = null;
+    private String nextProtos = null;
+
+    public SSLConfiguration(String certPath, String keyPath, String cipherSpec,
+                            String keyPassword, String caPath, String nextProtos)
+            throws IncompleteConfiguration {
+        this.certPath = certPath;
+        this.keyPath = keyPath;
+        this.cipherSpec = cipherSpec;
+        this.keyPassword = keyPassword;
+        this.caPath = caPath;
+        this.nextProtos = nextProtos;
+        verifyCorrectConstruction();
+    }
+
+    /**
+     * Construct a SSLConfiguration with data from the given Map.
+     *
+     * @param map The Map containing keys corresponding to the values of  CERT_PATH, KEY_PATH,
+     * CIPHER_SPEC, KEY_PASSWORD, and CA_PATH.
+     *
+     * @throws IncompleteConfiguration if required fields are not assigned.
+     */
+    public SSLConfiguration(Map map) throws IncompleteConfiguration {
+        assignFromMap(map);
+        verifyCorrectConstruction();
+    }
+
+    /**
+     * Assert all required fields are present, and set defaults for unassigned optional fields.
+     * @throws IncompleteConfiguration if required fields are not assigned
+     */
+    private void verifyCorrectConstruction() throws IncompleteConfiguration {
+        assertRequiredFieldsAssigned();
+        assignDefaultsToUnassignedOptionalFields();
+    }
+
+    /**
+     * Assign fields from the given Map.
+     *
+     * @param map the Map to assign from.
+     * @throws IncompleteConfiguration if required fields are not assigned
+     */
+    private void assignFromMap(Map map) throws IncompleteConfiguration {
+        // Assign required fields
+        this.certPath = (String)map.get(CERT_PATH);
+        this.keyPath = (String)map.get(KEY_PATH);
+        this.cipherSpec = (String)map.get(CIPHER_SPEC);
+
+        // Assign optional fields
+        this.keyPassword= (String)map.get(KEY_PASSWORD);
+        this.caPath = (String)map.get(CA_PATH);
+        this.nextProtos = (String)map.get(NEXT_PROTOS);
+    }
+
+    /**
+     * Assert that all required fields have been assigned.
+     *
+     * @throws IncompleteConfiguration if a required value is not set.
+     */
+    private void assertRequiredFieldsAssigned()
+            throws IncompleteConfiguration {
+        if (certPath == null || certPath.isEmpty())
+            throw new IncompleteConfiguration("certPath");
+
+        if (keyPath == null || keyPath.isEmpty())
+            throw new IncompleteConfiguration("keyPath");
+
+        if (cipherSpec == null || cipherSpec.isEmpty())
+            throw new IncompleteConfiguration("cipherSpec");
+    }
+
+    private void assignDefaultsToUnassignedOptionalFields() {
+        if (keyPassword == null) keyPassword = "";
+        if (caPath == null) caPath = "";
+        if (nextProtos == null) nextProtos = "";
+    }
+
+
+    public String getCertPath() {
+        return certPath;
+    }
+
+    public void setCertPath(String certPath) {
+        this.certPath = certPath;
+    }
+
+    public String getKeyPath() {
+        return keyPath;
+    }
+
+    public void setKeyPath(String keyPath) {
+        this.keyPath = keyPath;
+    }
+
+    public String getCipherSpec() {
+        return cipherSpec;
+    }
+
+    public void setCipherSpec(String cipherSpec) {
+        this.cipherSpec = cipherSpec;
+    }
+
+    public String getKeyPassword() {
+        return keyPassword;
+    }
+
+    public void setKeyPassword(String keyPassword) {
+        this.keyPassword = keyPassword;
+    }
+
+    public String getCaPath() {
+        return caPath;
+    }
+
+    public void setCaPath(String caPath) {
+        this.caPath = caPath;
+    }
+
+    public void setNextProtos(String nextProtos) {
+        this.nextProtos = nextProtos;
+    }
+
+    public String getNextProtos() {
+        return nextProtos;
+    }
+}
diff --git a/jni/java/org/apache/tomcat/jni/ssl/SSLContextHolder.java b/jni/java/org/apache/tomcat/jni/ssl/SSLContextHolder.java
new file mode 100644
index 0000000..94e4218
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/SSLContextHolder.java
@@ -0,0 +1,71 @@
+package org.apache.tomcat.jni.ssl;
+
+import org.apache.tomcat.jni.Pool;
+import org.apache.tomcat.jni.SSL;
+import org.apache.tomcat.jni.SSLContext;
+
+/**
+ * Encapsulates an OpenSSL SSL_CTX object.
+ */
+public class SSLContextHolder {
+    private long sslContext = 0L;
+
+    /**
+     * Create an SSLContext from the given SSLConfiguration
+     * @param sslConfiguration the SSLConfiguration
+     */
+    public SSLContextHolder(long pool, SSLConfiguration sslConfiguration) throws Exception {
+        synchronized (SSLContextHolder.class) {
+            sslContext = SSLContext.make(pool,
+                                         SSL.SSL_PROTOCOL_ALL,
+                                         SSL.SSL_MODE_SERVER);
+
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_ALL);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_NO_SSLv2);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_SINGLE_ECDH_USE);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_SINGLE_DH_USE);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
+
+            /* List the ciphers that the client is permitted to negotiate. */
+            SSLContext.setCipherSuite(sslContext, sslConfiguration.getCipherSpec());
+
+            /* Set certificate verification policy. */
+            SSLContext.setVerify(sslContext, SSL.SSL_CVERIFY_NONE, 10);
+
+            final String certFilename = sslConfiguration.getCertPath();
+            final String certChainFilename = sslConfiguration.getCaPath();
+
+            /* Load the certificate file and private key. */
+            if (!SSLContext.setCertificate(sslContext,
+                                           certFilename,
+                                           sslConfiguration.getKeyPath(),
+                                           sslConfiguration.getKeyPassword(),
+                                           SSL.SSL_AIDX_RSA)) {
+                throw new Exception("Failed to set certificate file '" + certFilename + "': " +
+                                    SSL.getLastError());
+            }
+
+            /* Load certificate chain file, if specified */
+            if (certChainFilename != null && certChainFilename.length() > 0) {
+                /* If named same as cert file, we must skip the first cert since it was loaded above. */
+                boolean skipFirstCert = certFilename.equals(certChainFilename);
+
+                if (!SSLContext.setCertificateChainFile(sslContext, certChainFilename, skipFirstCert)) {
+                  throw new Exception("Failed to set certificate chain file '" + certChainFilename + "': " +
+                                      SSL.getLastError());
+                }
+            }
+
+            /* Set next protocols for next protocol negotiation extension, if specified */
+            String nextProtos = sslConfiguration.getNextProtos();
+            if (nextProtos != null && nextProtos.length() > 0) {
+                SSLContext.setNextProtos(sslContext, nextProtos);
+            }
+        }
+    }
+
+    protected long getSslContext() {
+        return sslContext;
+    }
+}
diff --git a/jni/native/include/ssl_private.h b/jni/native/include/ssl_private.h
index b88fa4c..c2f238f 100644
--- a/jni/native/include/ssl_private.h
+++ b/jni/native/include/ssl_private.h
@@ -257,6 +257,9 @@ struct tcn_ssl_ctxt_t {
     int             verify_depth;
     int             verify_mode;
     tcn_pass_cb_t   *cb_data;
+
+    unsigned char   *next_proto_data;
+    unsigned int    next_proto_len;
 };
 
   
@@ -311,5 +314,6 @@ void        SSL_callback_handshake(const SSL *, int, int);
 int         SSL_CTX_use_certificate_chain(SSL_CTX *, const char *, int);
 int         SSL_callback_SSL_verify(int, X509_STORE_CTX *);
 int         SSL_rand_seed(const char *file);
+int         SSL_callback_next_protos(SSL *, const unsigned char **, unsigned int *, void *);
 
 #endif /* SSL_PRIVATE_H */
diff --git a/jni/native/src/ssl.c b/jni/native/src/ssl.c
index 83ad938..583d7cd 100644
--- a/jni/native/src/ssl.c
+++ b/jni/native/src/ssl.c
@@ -856,20 +856,24 @@ static int jbs_free(BIO *bi)
 
 static int jbs_write(BIO *b, const char *in, int inl)
 {
-    jint ret = 0;
+    jint ret = -1;
     if (b->init && in != NULL) {
         BIO_JAVA *j = (BIO_JAVA *)b->ptr;
         JNIEnv   *e = NULL;
-        jbyteArray jb = (*e)->NewByteArray(e, inl);
         tcn_get_java_env(&e);
+        jbyteArray jb = (*e)->NewByteArray(e, inl);
         if (!(*e)->ExceptionOccurred(e)) {
+            BIO_clear_retry_flags(b);
             (*e)->SetByteArrayRegion(e, jb, 0, inl, (jbyte *)in);
             ret = (*e)->CallIntMethod(e, j->cb.obj,
                                       j->cb.mid[0], jb);
-            (*e)->ReleaseByteArrayElements(e, jb, (jbyte *)in, JNI_ABORT);
             (*e)->DeleteLocalRef(e, jb);
         }
     }
+    if (ret == 0) {
+        BIO_set_retry_write(b);
+        ret = -1;
+    }
     return ret;
 }
 
@@ -879,15 +883,19 @@ static int jbs_read(BIO *b, char *out, int outl)
     if (b->init && out != NULL) {
         BIO_JAVA *j = (BIO_JAVA *)b->ptr;
         JNIEnv   *e = NULL;
-        jbyteArray jb = (*e)->NewByteArray(e, outl);
         tcn_get_java_env(&e);
+        jbyteArray jb = (*e)->NewByteArray(e, outl);
         if (!(*e)->ExceptionOccurred(e)) {
+            BIO_clear_retry_flags(b);
             ret = (*e)->CallIntMethod(e, j->cb.obj,
                                       j->cb.mid[1], jb);
             if (ret > 0) {
                 jbyte *jout = (*e)->GetPrimitiveArrayCritical(e, jb, NULL);
                 memcpy(out, jout, ret);
                 (*e)->ReleasePrimitiveArrayCritical(e, jb, jout, 0);
+            } else if (outl != 0) {
+                ret = -1;
+                BIO_set_retry_read(b);
             }
             (*e)->DeleteLocalRef(e, jb);
         }
@@ -935,7 +943,16 @@ static int jbs_gets(BIO *b, char *out, int outl)
 
 static long jbs_ctrl(BIO *b, int cmd, long num, void *ptr)
 {
-    return 0;
+    int ret = 0;
+    switch (cmd) {
+        case BIO_CTRL_FLUSH:
+            ret = 1;
+            break;
+        default:
+            ret = 0;
+            break;
+    }
+    return ret;
 }
 
 static BIO_METHOD jbs_methods = {
@@ -1087,7 +1104,230 @@ TCN_IMPLEMENT_CALL(jboolean, SSL, hasOp)(TCN_STDARGS, jint op)
     return op == (op & supported_ssl_opts) ? JNI_TRUE : JNI_FALSE;
 }
 
+/*** Begin Twitter 1:1 API addition ***/
+TCN_IMPLEMENT_CALL(jint, SSL, getLastErrorNumber)(TCN_STDARGS) {
+    UNREFERENCED_STDARGS;
+    return ERR_get_error();
+}
+
+TCN_IMPLEMENT_CALL(jlong /* SSL * */, SSL, newSSL)(TCN_STDARGS,
+                                                   jlong ctx /* tcn_ssl_ctxt_t * */,
+                                                   jboolean server) {
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    UNREFERENCED_STDARGS;
+    TCN_ASSERT(ctx != 0);
+    SSL *ssl = SSL_new(c->ctx);
+    if (ssl == NULL) {
+        tcn_ThrowException(e, "cannot create new ssl");
+        return 0;
+    }
+    if (server) {
+        SSL_set_accept_state(ssl);
+    } else {
+        SSL_set_connect_state(ssl);
+    }
+    return P2J(ssl);
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, setBIO)(TCN_STDARGS,
+                                      jlong ssl /* SSL * */,
+                                      jlong rbio /* BIO * */,
+                                      jlong wbio /* BIO * */) {
+    UNREFERENCED_STDARGS;
+    SSL_set_bio(J2P(ssl, SSL *), J2P(rbio, BIO *), J2P(wbio, BIO *));
+    return;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, getError)(TCN_STDARGS,
+                                       jlong ssl /* SSL * */,
+                                       jint ret) {
+    UNREFERENCED_STDARGS;
+    return SSL_get_error(J2P(ssl, SSL*), ret);
+}
+
+// How much did SSL write into this BIO?
+TCN_IMPLEMENT_CALL(jint /* nbytes */, SSL, pendingWrittenBytesInBIO)(TCN_STDARGS,
+                                                                     jlong bio /* BIO * */) {
+    UNREFERENCED_STDARGS;
+
+    return BIO_ctrl_pending(J2P(bio, BIO *));
+}
+
+// How much is available for reading in the given SSL struct?
+TCN_IMPLEMENT_CALL(jint, SSL, pendingReadableBytesInSSL)(TCN_STDARGS, jlong ssl /* SSL * */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_pending(J2P(ssl, SSL *));
+}
+
+// Write wlen bytes from wbuf into bio
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, writeToBIO)(TCN_STDARGS,
+                                                       jlong bio /* BIO * */,
+                                                       jlong wbuf /* char* */,
+                                                       jint wlen /* sizeof(wbuf) */) {
+    UNREFERENCED_STDARGS;
+
+    return BIO_write(J2P(bio, BIO *), J2P(wbuf, void *), wlen);
+
+}
+
+// Read up to rlen bytes from bio into rbuf
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, readFromBIO)(TCN_STDARGS,
+                                                        jlong bio /* BIO * */,
+                                                        jlong rbuf /* char * */,
+                                                        jint rlen /* sizeof(rbuf) - 1 */) {
+    UNREFERENCED_STDARGS;
+
+    return BIO_read(J2P(bio, BIO *), J2P(rbuf, void *), rlen);
+}
+
+// Write up to wlen bytes of application data to the ssl BIO (encrypt)
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, writeToSSL)(TCN_STDARGS,
+                                                       jlong ssl /* SSL * */,
+                                                       jlong wbuf /* char * */,
+                                                       jint wlen /* sizeof(wbuf) */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_write(J2P(ssl, SSL *), J2P(wbuf, void *), wlen);
+}
+
+// Read up to rlen bytes of application data from the given SSL BIO (decrypt)
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, readFromSSL)(TCN_STDARGS,
+                                                        jlong ssl /* SSL * */,
+                                                        jlong rbuf /* char * */,
+                                                        jint rlen /* sizeof(rbuf) - 1 */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_read(J2P(ssl, SSL *), J2P(rbuf, void *), rlen);
+}
+
+// Get the shutdown status of the engine
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, getShutdown)(TCN_STDARGS,
+                                                        jlong ssl /* SSL * */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_get_shutdown(J2P(ssl, SSL *));
+}
+
+// Called when the peer closes the connection
+TCN_IMPLEMENT_CALL(void, SSL, setShutdown)(TCN_STDARGS,
+                                           jlong ssl /* SSL * */,
+                                           jint mode) {
+    UNREFERENCED_STDARGS;
+
+    SSL_set_shutdown(J2P(ssl, SSL *), mode);
+}
+
+// Free the SSL * and its associated internal BIO
+TCN_IMPLEMENT_CALL(void, SSL, freeSSL)(TCN_STDARGS,
+                                       jlong ssl /* SSL * */) {
+    UNREFERENCED_STDARGS;
+
+    SSL_free(J2P(ssl, SSL *));
+}
+
+// Make a BIO pair (network and internal) for the provided SSL * and return the network BIO
+TCN_IMPLEMENT_CALL(jlong, SSL, makeNetworkBIO)(TCN_STDARGS,
+                                               jlong ssl /* SSL * */) {
+    SSL *ssl_ = J2P(ssl, SSL *);
+
+    UNREFERENCED(o);
+
+    if (ssl_ == NULL) {
+        tcn_ThrowException(e, "ssl is null");
+        goto fail;
+    }
+
+    BIO *internal_bio;
+    BIO *network_bio;
+
+    if (BIO_new_bio_pair(&internal_bio, 0, &network_bio, 0) != 1) {
+        tcn_ThrowException(e, "BIO_new_bio_pair failed");
+        goto fail;
+    }
+
+    SSL_set_bio(ssl_, internal_bio, internal_bio);
+
+    return P2J(network_bio);
+ fail:
+    return 0;
+}
+
+// Free a BIO * (typically, the network BIO)
+TCN_IMPLEMENT_CALL(void, SSL, freeBIO)(TCN_STDARGS,
+                                       jlong bio /* BIO * */) {
+    UNREFERENCED_STDARGS;
+
+    BIO *bio_ = J2P(bio, BIO *);
+    BIO_free(bio_);
+}
+
+// Send CLOSE_NOTIFY to peer
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, shutdownSSL)(TCN_STDARGS,
+                                                        jlong ssl /* SSL * */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_shutdown(J2P(ssl, SSL *));
+}
+
+// Read which cipher was negotiated for the given SSL *.
+TCN_IMPLEMENT_CALL(jstring, SSL, getCipherForSSL)(TCN_STDARGS,
+                                                  jlong ssl /* SSL * */)
+{
+    UNREFERENCED_STDARGS;
+
+    return AJP_TO_JSTRING(SSL_get_cipher(J2P(ssl, SSL*)));
+}
+
+// Is the handshake over yet?
+TCN_IMPLEMENT_CALL(jint, SSL, isInInit)(TCN_STDARGS,
+                                        jlong ssl /* SSL * */) {
+    SSL *ssl_ = J2P(ssl, SSL *);
+
+    UNREFERENCED(o);
+
+    if (ssl_ == NULL) {
+        tcn_ThrowException(e, "ssl is null");
+        return 0;
+    } else {
+        return SSL_in_init(ssl_);
+    }
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, doHandshake)(TCN_STDARGS,
+                                           jlong ssl /* SSL * */) {
+    SSL *ssl_ = J2P(ssl, SSL *);
+    if (ssl_ == NULL) {
+        tcn_ThrowException(e, "ssl is null");
+        return 0;
+    }
+
+    UNREFERENCED(o);
+
+    return SSL_do_handshake(ssl_);
+}
+
+// Read which protocol was negotiated for the given SSL *.
+TCN_IMPLEMENT_CALL(jstring, SSL, getNextProtoNegotiated)(TCN_STDARGS,
+                                                         jlong ssl /* SSL * */) {
+    SSL *ssl_ = J2P(ssl, SSL *);
+    if (ssl_ == NULL) {
+        tcn_ThrowException(e, "ssl is null");
+        return 0;
+    }
+    const unsigned char *proto;
+    unsigned int proto_len;
+
+    UNREFERENCED(o);
+
+    SSL_get0_next_proto_negotiated(ssl_, &proto, &proto_len);
+    return tcn_new_stringn(e, proto, proto_len);
+}
+/*** End Twitter API Additions ***/
+
 #else
+#error OpenSSL is required!
+
 /* OpenSSL is not supported.
  * Create empty stubs.
  */
@@ -1206,4 +1446,146 @@ TCN_IMPLEMENT_CALL(jboolean, SSL, hasOp)(TCN_STDARGS, jint op)
     UNREFERENCED(op);
     return JNI_FALSE;
 }
+
+/*** Begin Twitter 1:1 API addition ***/
+TCN_IMPLEMENT_CALL(jint, SSL, getLastErrorNumber)(TCN_STDARGS) {
+  UNREFERENCED(o);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSL, newSSL)(TCN_STDARGS, jlong ssl_ctx) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl_ctx);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, setBIO)(TCN_STDARGS, jlong ssl, jlong rbio, jlong wbio) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  UNREFERENCED(rbio);
+  UNREFERENCED(wbio);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, pendingWrittenBytesInBIO)(TCN_STDARGS, jlong bio) {
+  UNREFERENCED(o);
+  UNREFERENCED(bio);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, pendingReadableBytesInSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, writeToBIO)(TCN_STDARGS, jlong bio, jlong wbuf, jint wlen) {
+  UNREFERENCED(o);
+  UNREFERENCED(bio);
+  UNREFERENCED(wbuf);
+  UNREFERENCED(wlen);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, readFromBIO)(TCN_STDARGS, jlong bio, jlong rbuf, jint rlen) {
+  UNREFERENCED(o);
+  UNREFERENCED(bio);
+  UNREFERENCED(rbuf);
+  UNREFERENCED(rlen);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, writeToSSL)(TCN_STDARGS, jlong ssl, jlong wbuf, jint wlen) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  UNREFERENCED(wbuf);
+  UNREFERENCED(wlen);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, readFromSSL)(TCN_STDARGS, jlong ssl, jlong rbuf, jint rlen) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  UNREFERENCED(rbuf);
+  UNREFERENCED(rlen);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, getShutdown)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, setShutdown)(TCN_STDARGS, jlong ssl, jint mode) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  UNREFERENCED(mode);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, freeSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSL, makeNetworkBIO)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, freeBIO)(TCN_STDARGS, jlong bio) {
+  UNREFERENCED(o);
+  UNREFERENCED(bio);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, shutdownSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jstring, SSL, getCipherForSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return NULL;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, isInInit)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, doHandshake)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(jstring, SSL, getNextProtoNegotiated)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return NULL;
+}
+
+/*** End Twitter 1:1 API addition ***/
+
 #endif
diff --git a/jni/native/src/sslcontext.c b/jni/native/src/sslcontext.c
index 59414be..9f142b2 100644
--- a/jni/native/src/sslcontext.c
+++ b/jni/native/src/sslcontext.c
@@ -138,19 +138,42 @@ TCN_IMPLEMENT_CALL(jlong, SSLContext, make)(TCN_STDARGS, jlong pool,
      */
     SSL_CTX_set_options(c->ctx, SSL_OP_SINGLE_DH_USE);
 
+#ifdef SSL_OP_NO_COMPRESSION
+    SSL_CTX_set_options(c->ctx, SSL_OP_NO_COMPRESSION);
+#else
+#error "SSL_OP_NO_COMPRESSION not supported in your version of OpenSSL"
+#endif
+
 #ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
     /*
      * Disallow a session from being resumed during a renegotiation,
      * so that an acceptable cipher suite can be negotiated.
      */
     SSL_CTX_set_options(c->ctx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
+#else
+#error "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION not supported in your version of OpenSSL"
+#endif
+
+#ifdef SSL_MODE_RELEASE_BUFFERS
+    /* Release idle buffers to the SSL_CTX free list */
+    SSL_CTX_set_mode(c->ctx, SSL_MODE_RELEASE_BUFFERS);
+#else
+#error "SSL_MODE_RELEASE_BUFFERS not supported in your version of OpenSSL"
 #endif
-    /* Default session context id and cache size */
-    SSL_CTX_sess_set_cache_size(c->ctx, SSL_DEFAULT_CACHE_SIZE);
+
+    /* Session cache is disabled by default */
+    SSL_CTX_set_session_cache_mode(c->ctx, SSL_SESS_CACHE_OFF);
+    /* Longer session timeout */
+    SSL_CTX_set_timeout(c->ctx, 14400);
     EVP_Digest((const unsigned char *)SSL_DEFAULT_VHOST_NAME,
                (unsigned long)((sizeof SSL_DEFAULT_VHOST_NAME) - 1),
                &(c->context_id[0]), NULL, EVP_sha1(), NULL);
     if (mode) {
+        /* Set default (nistp256) elliptic curve for ephemeral ECDH keys */
+        EC_KEY *ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
+        SSL_CTX_set_tmp_ecdh(c->ctx, ecdh);
+        EC_KEY_free(ecdh);
+
         SSL_CTX_set_tmp_rsa_callback(c->ctx, SSL_callback_tmp_RSA);
         SSL_CTX_set_tmp_dh_callback(c->ctx,  SSL_callback_tmp_DH);
     }
@@ -656,6 +679,166 @@ cleanup:
     return rv;
 }
 
+TCN_IMPLEMENT_CALL(void, SSLContext, setNextProtos)(TCN_STDARGS, jlong ctx,
+                                                    jstring next_protos)
+{
+    int i, len, start = 0;
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    TCN_ALLOC_CSTRING(next_protos);
+
+    TCN_ASSERT(ctx != 0);
+    UNREFERENCED(o);
+
+    // Convert comma separated next_protos string to wire format
+    if (J2S(next_protos)) {
+        len = (int)strlen(J2S(next_protos));
+        if (len <= 65535) {
+        c->next_proto_len = (unsigned int)(strlen(J2S(next_protos)) + 1);
+            if ((c->next_proto_data = apr_palloc(c->pool, len + 1)) != NULL) {
+                c->next_proto_len = len + 1;
+                for (i = 0; i <= len; i++) {
+                    if (i == len || J2S(next_protos)[i] == ',') {
+                        if (i - start > 255) {
+                            c->next_proto_data = NULL;
+                            c->next_proto_len = 0;
+                            break;
+                        }
+                        (c->next_proto_data)[start] = i - start;
+                        start = i + 1;
+                    } else {
+                        (c->next_proto_data)[i+1] = J2S(next_protos)[i];
+                    }
+                }
+            }
+        }
+    }
+
+    // If conversion was successful set callback function
+    if (c->next_proto_data) {
+        SSL_CTX_set_next_protos_advertised_cb(c->ctx, SSL_callback_next_protos, (void *)c);
+    }
+
+    TCN_FREE_CSTRING(next_protos);
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, setSessionCacheTimeout)(TCN_STDARGS, jlong ctx, jlong timeout)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_set_timeout(c->ctx, timeout);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, setSessionCacheSize)(TCN_STDARGS, jlong ctx, jlong size)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = 0;
+
+    /* Prevent unbounded session cache sizes. */
+    if (size > 0) {
+      SSL_CTX_set_session_cache_mode(c->ctx, SSL_SESS_CACHE_SERVER);
+      rv = SSL_CTX_sess_set_cache_size(c->ctx, size);
+    }
+
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionNumber)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_number(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionConnect)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_connect(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionConnectGood)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_connect_good(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionConnectRenegotiate)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_connect_renegotiate(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionAccept)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_accept(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionAcceptGood)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_accept_good(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionAcceptRenegotiate)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_accept_renegotiate(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionHits)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_hits(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionCbHits)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_cb_hits(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionMisses)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_misses(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionTimeouts)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_timeouts(c->ctx);
+    return rv;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionCacheFull)(TCN_STDARGS, jlong ctx)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    jlong rv = SSL_CTX_sess_cache_full(c->ctx);
+    return rv;
+}
+
+#define TICKET_KEYS_SIZE 48
+TCN_IMPLEMENT_CALL(void, SSLContext, setSessionTicketKeys)(TCN_STDARGS, jlong ctx, jbyteArray keys)
+{
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    if ((*e)->GetArrayLength(e, keys) != TICKET_KEYS_SIZE) {
+      BIO_printf(c->bio_os, "[ERROR] Session ticket keys provided were wrong size.");
+      exit(1);
+    }
+    jbyte* b = (*e)->GetByteArrayElements(e, keys, NULL);
+    SSL_CTX_set_tlsext_ticket_keys(c->ctx, b, TICKET_KEYS_SIZE);
+    (*e)->ReleaseByteArrayElements(e, keys, b, 0);
+}
+
 #else
 /* OpenSSL is not supported.
  * Create empty stubs.
@@ -800,4 +983,126 @@ TCN_IMPLEMENT_CALL(jboolean, SSLContext, setCertificate)(TCN_STDARGS, jlong ctx,
     return JNI_FALSE;
 }
 
+TCN_IMPLEMENT_CALL(void, SSLContext, setNextProtos)(TCN_STDARGS, jlong ctx,
+                                                    jstring next_protos)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    UNREFERENCED(next_protos);
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, setSessionCacheTimeout)(TCN_STDARGS, jlong ctx, jlong timeout)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    UNREFERENCED(timeout);
+    return -1;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, setSessionCacheSize)(TCN_STDARGS, jlong ctx, jlong size)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    UNREFERENCED(size);
+    return -1;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionNumber)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionConnect)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionConnectGood)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionConnectRenegotiate)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionAccept)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionAcceptGood)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionAcceptRenegotiate)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionHits)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionCbHits)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionTimeouts)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionCacheFull)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionMisses)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSLContext, sessionHits)(TCN_STDARGS, jlong ctx)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    return 0;
+}
+
+TCN_IMPLEMENT_CALL(void, SSLContext, setSessionTicketKeys)(TCN_STDARGS, jlong ctx, jbyteArray keys)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    UNREFERENCED(keys);
+}
+
 #endif
diff --git a/jni/native/src/sslutils.c b/jni/native/src/sslutils.c
index b2b6a46..b4c4ba1 100644
--- a/jni/native/src/sslutils.c
+++ b/jni/native/src/sslutils.c
@@ -733,6 +733,17 @@ void SSL_callback_handshake(const SSL *ssl, int where, int rc)
 
 }
 
+int SSL_callback_next_protos(SSL *ssl, const unsigned char **data,
+                             unsigned int *len, void *arg)
+{
+    tcn_ssl_ctxt_t *ssl_ctxt = arg;
+
+    *data = ssl_ctxt->next_proto_data;
+    *len = ssl_ctxt->next_proto_len;
+
+    return SSL_TLSEXT_ERR_OK;
+}
+
 #ifdef HAVE_OPENSSL_OCSP
 
 /* Function that is used to do the OCSP verification */
