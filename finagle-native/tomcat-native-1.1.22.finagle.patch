diff --git a/jni/build.properties.default b/jni/build.properties.default
index e5d3935..095693e 100644
--- a/jni/build.properties.default
+++ b/jni/build.properties.default
@@ -30,9 +30,9 @@ base.path=/usr/share/java
 #base.path=C:/path/to/the/repository
 #base.path=/usr/local
 
-compile.source=1.4
-compile.target=1.4
-compile.debug=off
+compile.source=1.6
+compile.target=1.6
+compile.debug=on
 compile.deprecation=on
 compile.optimize=on
 
diff --git a/jni/build.xml b/jni/build.xml
index f66721d..46069ae 100644
--- a/jni/build.xml
+++ b/jni/build.xml
@@ -54,8 +54,8 @@
     <property name="dist.root" value="./dist"/>
     <property name="ant.home" value="."/>
 
-    <property name="compile.source" value="1.4"/>
-    <property name="compile.target" value="1.4"/>
+    <property name="compile.source" value="1.6"/>
+    <property name="compile.target" value="1.6"/>
     <property name="compile.debug" value="off"/>
     <property name="compile.optimize" value="on"/>
     <property name="compile.deprecation" value="on"/>
@@ -103,7 +103,7 @@
     </target>
 
     <target name="prepare" depends="env">
-       <mkdir dir="${build.dir}"/>
+        <mkdir dir="${build.dir}" />
     </target>
 
     <!-- Download and dependency building -->
diff --git a/jni/java/org/apache/tomcat/jni/SSL.java b/jni/java/org/apache/tomcat/jni/SSL.java
index 329411a..6d1880e 100644
--- a/jni/java/org/apache/tomcat/jni/SSL.java
+++ b/jni/java/org/apache/tomcat/jni/SSL.java
@@ -17,6 +17,8 @@
 
 package org.apache.tomcat.jni;
 
+import java.nio.ByteBuffer;
+
 /** SSL
  *
  * @author Mladen Turk
@@ -340,5 +342,168 @@ public final class SSL {
      */
     public static native boolean hasOp(int op);
 
+    /*
+     * Begin Twitter API additions
+     */
+
+    public static final int SSL_SENT_SHUTDOWN = 1;
+    public static final int SSL_RECEIVED_SHUTDOWN = 2;
+
+    /**
+     * SSL_new
+     * @param ssl_ctx SSL context pointer (SSL_CTX *)
+     * @return pointer to SSL instance (SSL *)
+     */
+    public static native long newSSL(long ssl_ctx);
+
+    /**
+     * BIO_ctrl_pending
+     * @param bio BIO pointer (BIO *)
+     * @return
+     */
+    public static native int pendingWrittenBytesInBIO(long bio);
+
+    /**
+     * SSL_pending
+     * @param ssl SSL pointer (SSL *)
+     * @return
+     */
+    public static native int pendingReadableBytesInSSL(long ssl);
+
+    /**
+     * BIO_write
+     * @param bio
+     * @param wbuf
+     * @param wlen
+     * @return
+     */
+    public static native int writeToBIO(long bio, long wbuf, int wlen);
+
+    /**
+     * BIO_read
+     * @param bio
+     * @param rbuf
+     * @param rlen
+     * @return
+     */
+    public static native int readFromBIO(long bio, long rbuf, int rlen);
+
+    /**
+     * SSL_write
+     * @param ssl the SSL instance (SSL *)
+     * @param wbuf
+     * @param wlen
+     * @return
+     */
+    public static native int writeToSSL(long ssl, long wbuf, int wlen);
+
+    /**
+     * SSL_read
+     * @param ssl the SSL instance (SSL *)
+     * @param rbuf
+     * @param rlen
+     * @return
+     */
+    public static native int readFromSSL(long ssl, long rbuf, int rlen);
+
+    /**
+     * SSL_get_shutdown
+     * @param ssl the SSL instance (SSL *)
+     * @return
+     */
+    public static native int getShutdown(long ssl);
+
+    /**
+     * SSL_set_shutdown
+     * @param ssl the SSL instance (SSL *)
+     * @param mode
+     */
+    public static native void setShutdown(long ssl, int mode);
+
+    /**
+     * SSL_free
+     * @param ssl the SSL instance (SSL *)
+     */
+    public static native void freeSSL(long ssl);
+
+    /**
+     * Wire up internal and network BIOs for the given SSL instance.
+     *
+     * <b>Warning: you must explicitly free this resource by calling freeBIO</b>
+     *
+     * While the SSL's internal/application data BIO will be freed when freeSSL is called on
+     * the provided SSL instance, you must call freeBIO on the returned network BIO.
+     *
+     * @param ssl the SSL instance (SSL *)
+     * @return pointer to the Network BIO (BIO *)
+     */
+    public static native long makeNetworkBIO(long ssl);
+
+    /**
+     * BIO_free
+     * @param bio
+     */
+    public static native void freeBIO(long bio);
+
+    /**
+     * BIO_flush
+     * @param bio
+     */
+    public static native void flushBIO(long bio);
+
+    /**
+     * SSL_shutdown
+     * @param ssl the SSL instance (SSL *)
+     * @return
+     */
+    public static native int shutdownSSL(long ssl);
+
+    /**
+     * Get the error number representing the last error OpenSSL encountered on this thread.
+     * @return
+     */
+    public static native int getLastErrorNumber();
+
+    /**
+     * SSL_get_cipher
+     * @param ssl the SSL instance (SSL *)
+     * @return
+     */
+    public static native String getCipherForSSL(long ssl);
+
+    /**
+     * Get an OpenSSL SSL context (SSL_CTX *) from a TCNative SSL Context (tcn_ssl_ctxt_t *).
+     *
+     * @param tcn_ssl_ctxt SSLContext (tcn_ssl_ctxt_t *)
+     * @return underlying OpenSSL SSL context (SSL_CTX*)
+     */
+    public static native long getSSLCTXFromSSLContext(long tcn_ssl_ctxt);
+
+    /**
+     * Put the provided SSL instance (SSL *) into accept mode by calling SSL_set_accept_state and
+     * SSL_do_handshake.
+     *
+     * @throws Exception if SSL_do_handshake returns SSL_ERROR_SSL.
+     * @param ssl the SSL context instance
+     */
+    public static native void acceptConnectionOnSSL(long ssl);
+
+    /**
+     * SSL_in_init
+     * @param SSL
+     * @return
+     */
+    public static native int isInInit(long SSL);
+
+    /**
+     * SSL_get0_next_proto_negotiated
+     * @param ssl the SSL isntance (SSL *)
+     * @return
+     */
+    public static native String getNextProtoNegotiated(long ssl);
+
+    /*
+     * End Twitter API Additions
+     */
 }
 
diff --git a/jni/java/org/apache/tomcat/jni/SSLContext.java b/jni/java/org/apache/tomcat/jni/SSLContext.java
index 73d7d19..382bbd2 100644
--- a/jni/java/org/apache/tomcat/jni/SSLContext.java
+++ b/jni/java/org/apache/tomcat/jni/SSLContext.java
@@ -281,4 +281,10 @@ public final class SSLContext {
      */
     public static native void setVerify(long ctx, int level, int depth);
 
+    /**
+     * Set next protocol for next protocol negotiation extension
+     * @param ctx Server context to use.
+     * @param next_protos comma deliniated list of protocols in priority order
+     */
+    public static native void setNextProtos(long ctx, String next_protos);
 }
diff --git a/jni/java/org/apache/tomcat/jni/ssl/DirectBufferOperation.java b/jni/java/org/apache/tomcat/jni/ssl/DirectBufferOperation.java
new file mode 100644
index 0000000..a7278d4
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/DirectBufferOperation.java
@@ -0,0 +1,39 @@
+package org.apache.tomcat.jni.ssl;
+
+import org.apache.tomcat.jni.Buffer;
+
+import java.nio.ByteBuffer;
+
+abstract class DirectBufferOperation {
+    private final static RuntimeException ALLOCATION_INTERRUPTED =
+        new IllegalStateException("Buffer allocation interrupted");
+
+    private DirectBufferPool pool;
+
+    public DirectBufferOperation(DirectBufferPool pool) {
+        this.pool = pool;
+
+        ByteBuffer buffer = acquireDirectBuffer();
+        try {
+            run(buffer, Buffer.address(buffer));
+        } finally {
+            releaseDirectBuffer(buffer);
+        }
+    }
+
+    private ByteBuffer acquireDirectBuffer() {
+        try {
+            return pool.acquire();
+        } catch (InterruptedException e) {
+            throw ALLOCATION_INTERRUPTED;
+        }
+    }
+
+    private void releaseDirectBuffer(ByteBuffer buffer) {
+        buffer.rewind();
+        buffer.clear();
+        pool.release(buffer);
+    }
+
+    abstract void run(ByteBuffer buffer, long address);
+}
diff --git a/jni/java/org/apache/tomcat/jni/ssl/DirectBufferPool.java b/jni/java/org/apache/tomcat/jni/ssl/DirectBufferPool.java
new file mode 100644
index 0000000..413ac51
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/DirectBufferPool.java
@@ -0,0 +1,67 @@
+package org.apache.tomcat.jni.ssl;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Manages a pool of directly-allocated ByteBuffers.
+ *
+ * This is necessary as the reclamation of these buffers does not work appropriately
+ * on some platforms.
+ *
+ * TODO: Attempt to replace the directly-allocated ByteBuffers this with one APR pool.
+ */
+public class DirectBufferPool {
+    private LinkedBlockingQueue<ByteBuffer> buffers;
+
+    // BUFFER_SIZE must be large enough to accomodate the maximum SSL record size.
+    // Header (5) + Data (2^14) + Compression (1024) + Encryption (1024) + MAC (20) + Padding (256)
+    private final int BUFFER_SIZE = 18713;
+
+    /**
+     * Construct a new pool with the specified capacity.
+     *
+     * @param capacity The number of buffers to instantiate.
+     */
+    public DirectBufferPool(int capacity) {
+        buffers = new LinkedBlockingQueue<ByteBuffer>(capacity);
+        while (buffers.remainingCapacity() > 0) {
+            ByteBuffer buf = ByteBuffer.allocateDirect(BUFFER_SIZE);
+
+            buf.order(ByteOrder.nativeOrder());
+
+            buffers.offer(buf);
+        }
+    }
+
+    /**
+     * Take a buffer from the pool.
+     *
+     * @returns a ByteBuffer.
+     */
+    public ByteBuffer acquire() throws InterruptedException {
+        return buffers.take();
+    }
+
+    /**
+     * Release a buffer back into the stream
+     *
+     * @param buffer the ByteBuffer to release
+     */
+    public void release(ByteBuffer buffer) {
+        buffer.clear();
+        buffers.offer(buffer);
+    }
+
+    @Override
+    public String toString() {
+        return "[DirectBufferPool " +
+            buffers.size() + " buffers * " +
+            BUFFER_SIZE + " bytes = " +
+            buffers.size() * BUFFER_SIZE + " total bytes; " +
+            "size: " + buffers.size() +
+            " remainingCapacity: " + buffers.remainingCapacity() +
+            "]";
+    }
+}
diff --git a/jni/java/org/apache/tomcat/jni/ssl/OpenSSLEngine.java b/jni/java/org/apache/tomcat/jni/ssl/OpenSSLEngine.java
new file mode 100644
index 0000000..1837029
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/OpenSSLEngine.java
@@ -0,0 +1,720 @@
+package org.apache.tomcat.jni.ssl;
+
+import org.apache.tomcat.jni.SSL;
+
+import javax.net.ssl.*;
+import javax.security.cert.X509Certificate;
+import java.nio.ByteBuffer;
+import java.nio.ReadOnlyBufferException;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Implements a java.net.SSLEngine in terms of OpenSSL.
+ *
+ * Documentation on the dataflow and operation of SSLEngine and OpenSSL BIO abstractions
+ * can be found at:
+ *
+ *   SSLEngine: http://download.oracle.com/javase/1,5.0/docs/api/javax/net/ssl/SSLEngine.html
+ *   OpenSSL:   http://www.openssl.org/docs/crypto/BIO_s_bio.html#example
+ */
+public class OpenSSLEngine extends javax.net.ssl.SSLEngine {
+    private static final Logger LOG = Logger.getLogger(OpenSSLEngine.class.getName());
+
+    private static SSLException ENGINE_IS_CLOSED = new SSLException("Engine is closed");
+    private static SSLException RENEGOTIATION_NOT_SUPPORTED = new SSLException("Renegotiation is not supported");
+    private static SSLException ENCRYPTED_PACKET_OVERSIZE = new SSLException("Encrypted packet is oversize");
+
+    private static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14
+    private static final int MAX_COMPRESSED_LENGTH = MAX_PLAINTEXT_LENGTH + 1024;
+    private static final int MAX_CIPHERTEXT_LENGTH = MAX_COMPRESSED_LENGTH + 1024;
+    private static final int MAX_ENCRYPTED_PACKET = MAX_CIPHERTEXT_LENGTH + 5 + 20 + 256;
+
+    private static final String SSL_IGNORABLE_ERROR_PREFIX = "error:00000000:";
+
+    // String used to identify connections in debugging printing
+    private String identifier = null;
+
+    // OpenSSL state
+    private long ssl;
+    private long networkBIO;
+
+    private boolean accepted = false;
+    private boolean handshakeFinished = false;
+    private boolean receivedShutdown = false;
+    private AtomicBoolean destroyed = new AtomicBoolean(false);
+
+    private String cipher = null;
+    private String protocol = null;
+
+    // SSL Engine status variables
+    private boolean isInboundDone = false;
+    private boolean isOutboundDone = false;
+    private boolean engineClosed = false;
+
+    private DirectBufferPool bufferPool;
+
+    public OpenSSLEngine(SSLContextHolder contextHolder, DirectBufferPool bufferPool) {
+        this.bufferPool = bufferPool;
+        long sslCtx = SSL.getSSLCTXFromSSLContext(contextHolder.getSslContext());
+
+        synchronized (contextHolder) {
+            this.ssl = SSL.newSSL(sslCtx);
+        }
+        this.networkBIO = SSL.makeNetworkBIO(ssl);
+    }
+
+    public synchronized void shutdown() {
+        if (destroyed.compareAndSet(false, true)) {
+            SSL.freeSSL(ssl);
+            SSL.freeBIO(networkBIO);
+            ssl = networkBIO = 0;
+
+            // internal errors can cause shutdown without marking the engine closed
+            isInboundDone = isOutboundDone = engineClosed = true;
+        }
+    }
+
+    /**
+     * Write plaintext data to the OpenSSL internal BIO
+     *
+     * Calling this function with src.remaining == 0 is undefined.
+     */
+    private int writePlaintextData(final ByteBuffer src) {
+        final AtomicInteger written = new AtomicInteger(0);
+        new DirectBufferOperation(bufferPool) {
+            @Override
+            void run(ByteBuffer buffer, long address) {
+                int len = Math.min(src.remaining(), MAX_PLAINTEXT_LENGTH);
+                if (len > buffer.capacity())
+                    throw new RuntimeException("Buffer pool write overflow");
+
+                buffer.put(src.array(), src.position(), len);
+                int sslWrote = SSL.writeToSSL(ssl, address, len);
+                if (sslWrote > 0) {
+                    written.set(sslWrote);
+                    src.position(src.position() + sslWrote);
+                } else {
+                    throw new IllegalStateException();
+                }
+            }
+        };
+        return written.get();
+    }
+
+    /**
+     * Write encrypted data to the OpenSSL network BIO
+     */
+    private int writeEncryptedData(final ByteBuffer src, final AtomicInteger primingReadResult) {
+        final AtomicInteger written = new AtomicInteger(0);
+        new DirectBufferOperation(bufferPool) {
+            @Override
+            void run(ByteBuffer buffer, long address) {
+                int len = src.remaining();
+                if (len > buffer.capacity())
+                    throw new RuntimeException("Buffer pool write overflow");
+
+                buffer.put(src.array(), src.position(), len);
+                int netWrote = SSL.writeToBIO(networkBIO, address, len);
+                if (netWrote > -1) {
+                    written.set(netWrote);
+                    src.position(src.position() + netWrote);
+                    primingReadResult.set(SSL.readFromSSL(ssl, address, 0)); // priming read
+                }
+            }
+        };
+        return written.get();
+    }
+
+    /**
+     * Read plaintext data from the OpenSSL internal BIO
+     */
+    private int readPlaintextData(final ByteBuffer dst) {
+        final AtomicInteger read = new AtomicInteger(0);
+        new DirectBufferOperation(bufferPool) {
+            @Override
+            void run(ByteBuffer buffer, long address) {
+                buffer.limit(Math.min(buffer.limit(), dst.capacity()));
+                int sslRead = SSL.readFromSSL(ssl, address, buffer.limit());
+                if (sslRead > 0) {
+                    read.set(sslRead);
+                    buffer.get(dst.array(), dst.position(), sslRead);
+                    dst.position(dst.position() + sslRead);
+                }
+            }
+        };
+        return read.get();
+    }
+
+    /**
+     * Read encrypted data from the OpenSSL network BIO
+     */
+    private int readEncryptedData(final ByteBuffer dst, final int pending) {
+        final AtomicInteger read = new AtomicInteger(0);
+        new DirectBufferOperation(bufferPool) {
+            @Override
+            void run(ByteBuffer buffer, long address) {
+                if (pending > buffer.capacity())
+                    throw new RuntimeException("Network BIO read overflow (pending=" + pending +
+                                               "; capacity=" + buffer.capacity() + ")");
+
+                int bioRead = SSL.readFromBIO(networkBIO, address, pending);
+                if (bioRead > 0) {
+                    read.set(bioRead);
+                    buffer.limit(bioRead);
+                    buffer.get(dst.array(), dst.position(), bioRead);
+                    dst.position(dst.position() + bioRead);
+                }
+            }
+        };
+        return read.get();
+    }
+
+    /**
+     * Encrypt plaintext data from srcs buffers into dst buffer.
+     *
+     * This is called both to encrypt application data as well as
+     * to retrieve handshake data destined for the peer.
+     */
+    @Override
+    public synchronized SSLEngineResult wrap(final ByteBuffer[] srcs,
+                                             final int offset,
+                                             final int length,
+                                             final ByteBuffer dst)
+            throws SSLException {
+
+        int bytesConsumed = 0;
+        int bytesProduced = 0;
+
+        // Check to make sure the engine has not been closed
+        if (destroyed.get()) {
+            return new SSLEngineResult(SSLEngineResult.Status.CLOSED,
+                    SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING,
+                    bytesConsumed,
+                    bytesProduced);
+        }
+
+        // Throw required runtime exceptions
+        if ((null == srcs) || (null == dst)) throw new IllegalArgumentException();
+        if ((offset >= srcs.length) || (offset + length) > srcs.length)
+            throw new IndexOutOfBoundsException();
+        if (dst.isReadOnly())
+            throw new ReadOnlyBufferException();
+
+        // Prepare OpenSSL to work in server mode and receive handshake
+        if (!accepted) beginHandshake();
+
+        // In handshake or close_notify stages, check if call to wrap was made
+        // without regard to the handshake status.
+        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
+        if ((!handshakeFinished || engineClosed) &&
+                handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_UNWRAP))
+            return new SSLEngineResult(getEngineStatus(),
+                    handshakeStatus,
+                    bytesConsumed,
+                    bytesProduced);
+
+        { // Scope pendingNet
+            // Check for pending data in the network BIO
+            int pendingNet = SSL.pendingWrittenBytesInBIO(networkBIO);
+            if (pendingNet > 0) {
+                // Do we have enough room in dst to write encrypted data?
+                int capacity = dst.remaining();
+                if (capacity < pendingNet)
+                    return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,
+                                               handshakeStatus,
+                                               bytesConsumed,
+                                               bytesProduced);
+
+                // Write the pending data from the network BIO into the dst buffer
+                try {
+                    bytesProduced += readEncryptedData(dst, pendingNet);
+                } catch (Exception e) {
+                    throw new SSLException(e);
+                }
+
+                // If isOuboundDone is set, then the data from the network BIO
+                // was the close_notify message -- we are not required to wait
+                // for the receipt the peer's close_notify message -- shutdown.
+                if (isOutboundDone) shutdown();
+
+                return new SSLEngineResult(getEngineStatus(),
+                                           getHandshakeStatus(),
+                                           bytesConsumed,
+                                           bytesProduced);
+            }
+        }
+
+        // There was no pending data in the network BIO -- encrypt any application data
+        for (int i = offset; i < length; ++i) {
+            while (srcs[i].hasRemaining()) {
+
+                // Write plaintext application data to the SSL engine
+                try {
+                    bytesConsumed += writePlaintextData(srcs[i]);
+                } catch (Exception e) {
+                    throw new SSLException(e);
+                }
+
+                // Check to see if the engine wrote data into the network BIO
+                int pendingNet = SSL.pendingWrittenBytesInBIO(networkBIO);
+                if (pendingNet > 0) {
+                    // Do we have enough room in dst to write encrypted data?
+                    int capacity = dst.remaining();
+                    if (capacity < pendingNet)
+                        return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,
+                                getHandshakeStatus(),
+                                bytesConsumed,
+                                bytesProduced);
+
+                    // Write the pending data from the network BIO into the dst buffer
+                    try {
+                        bytesProduced += readEncryptedData(dst, pendingNet);
+                    } catch (Exception e) {
+                        throw new SSLException(e);
+                    }
+
+                    return new SSLEngineResult(getEngineStatus(),
+                            getHandshakeStatus(),
+                            bytesConsumed,
+                            bytesProduced);
+                }
+            }
+        }
+        return new SSLEngineResult(getEngineStatus(),
+                getHandshakeStatus(),
+                bytesConsumed,
+                bytesProduced);
+    }
+
+    /**
+     * Decrypt encrypted data from src buffers into dsts buffers.
+     */
+    @Override
+    public synchronized SSLEngineResult unwrap(final ByteBuffer src,
+                                               final ByteBuffer[] dsts,
+                                               final int offset,
+                                               final int length)
+            throws SSLException {
+
+        int bytesConsumed = 0;
+        int bytesProduced = 0;
+
+        // Check to make sure the engine has not been closed
+        if (destroyed.get()) {
+            return new SSLEngineResult(SSLEngineResult.Status.CLOSED,
+                    SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING,
+                    bytesConsumed,
+                    bytesProduced);
+        }
+
+        // Throw requried runtime exceptions
+        if ((null == src) || (null == dsts)) throw new IllegalArgumentException();
+        if ((offset >= dsts.length) || (offset + length > dsts.length))
+            throw new IndexOutOfBoundsException();
+
+        int capacity = 0;
+        for (int i = offset; i < offset + length; ++i) {
+            if (null == dsts[i]) throw new IllegalArgumentException();
+            if (dsts[i].isReadOnly()) throw new ReadOnlyBufferException();
+            capacity += dsts[i].remaining();
+        }
+
+        // Prepare OpenSSL to work in server mode and receive handshake
+        if (!accepted) beginHandshake();
+
+        // In handshake or close_notify stages, check if call to unwrap was made
+        // without regard to the handshake status.
+        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
+        if ((!handshakeFinished || engineClosed) &&
+                handshakeStatus.equals(SSLEngineResult.HandshakeStatus.NEED_WRAP))
+            return new SSLEngineResult(getEngineStatus(),
+                    handshakeStatus,
+                    bytesConsumed,
+                    bytesProduced);
+
+        // protect against protocol overflow attack vector
+        if (src.remaining() > MAX_ENCRYPTED_PACKET) {
+            isInboundDone = true;
+            isOutboundDone = true;
+            engineClosed = true;
+            shutdown();
+            throw ENCRYPTED_PACKET_OVERSIZE;
+        }
+
+        // Write encrypted data to network BIO
+        AtomicInteger primingReadResult = new AtomicInteger(0);
+        try {
+            bytesConsumed += writeEncryptedData(src, primingReadResult);
+        } catch (Exception e) {
+            throw new SSLException(e);
+        }
+
+        // Check for OpenSSL errors caused by the priming read
+        String error = SSL.getLastError();
+        if (error != null && !error.startsWith(SSL_IGNORABLE_ERROR_PREFIX)) {
+            if (LOG.isLoggable(Level.WARNING))
+                LOG.warning("Identifier: " + identifier + ": " +
+                            "SSL_read failed: primingReadResult: " + primingReadResult.get() +
+                            "; OpenSSL error: '" + error + "'");
+
+            // There was an internal error -- shutdown
+            shutdown();
+            throw new SSLException(error);
+        }
+
+        // There won't be any application data until we're done handshaking
+        int pendingApp = (SSL.isInInit(ssl) == 0) ? SSL.pendingReadableBytesInSSL(ssl) : 0;
+
+        // Do we have enough room in dsts to write decrypted data?
+        if (capacity < pendingApp)
+          return new SSLEngineResult(SSLEngineResult.Status.BUFFER_OVERFLOW,
+                                     getHandshakeStatus(),
+                                     bytesConsumed,
+                                     bytesProduced);
+
+        // Write decrypted data to dsts buffers
+        int idx = offset;
+        while (pendingApp > 0) {
+          while (dsts[idx].capacity() == 0) {
+            ++idx;
+          }
+
+          int bytesRead = 0;
+          try {
+              bytesRead = readPlaintextData(dsts[idx]);
+          } catch (Exception e) {
+              throw new SSLException(e);
+          }
+
+          if (bytesRead == 0) break;
+          bytesProduced += bytesRead;
+          pendingApp -= bytesRead;
+          if (dsts[idx].remaining() == 0) ++idx;
+        }
+
+        // Check to see if we received a close_notify message from the peer
+        if (!receivedShutdown && ((SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN)) {
+            receivedShutdown = true;
+            closeOutbound();
+            closeInbound();
+        }
+
+        return new SSLEngineResult(getEngineStatus(),
+                getHandshakeStatus(),
+                bytesConsumed,
+                bytesProduced);
+    }
+
+    /**
+     * Currently we do not delegate SSL computation tasks
+     * todo: in the future, possibly create tasks to do encrypt / decrypt async
+     */
+    @Override
+    public Runnable getDelegatedTask() {
+        return null;
+    }
+
+    /**
+     * This method is called on channel disconnection by SSLHandler when the server
+     * did not initiate the closure process to detect against truncation attacks.
+     */
+    @Override
+    public synchronized void closeInbound() throws SSLException {
+        if (isInboundDone) return;
+        isInboundDone = true;
+        engineClosed = true;
+        if (accepted) {
+            if (!receivedShutdown) {
+                shutdown();
+                throw new SSLException("close_notify has not been received");
+            }
+        } else {
+            // engine closing before initial handshake
+            shutdown();
+        }
+    }
+
+    @Override
+    public synchronized boolean isInboundDone() {
+        return isInboundDone || engineClosed;
+    }
+
+    /**
+     * This method is called on channel disconnection to send close_notify
+     */
+    @Override
+    public synchronized void closeOutbound() {
+        if (isOutboundDone) return;
+        isOutboundDone = true;
+        engineClosed = true;
+        if (accepted && !destroyed.get()) {
+            int mode = SSL.getShutdown(ssl);
+            if ((mode & SSL.SSL_SENT_SHUTDOWN) != SSL.SSL_SENT_SHUTDOWN)
+                SSL.shutdownSSL(ssl);
+        } else {
+            // engine closing before initial handshake
+            shutdown();
+        }
+    }
+
+    @Override
+    public synchronized boolean isOutboundDone() {
+        return isOutboundDone;
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        return new String[0];
+    }
+
+    @Override
+    public String[] getEnabledCipherSuites() {
+        return new String[0];
+    }
+
+    @Override
+    public void setEnabledCipherSuites(String[] strings) {
+    }
+
+    @Override
+    public String[] getSupportedProtocols() {
+        return new String[0];
+    }
+
+    @Override
+    public String[] getEnabledProtocols() {
+        return new String[0];
+    }
+
+    @Override
+    public void setEnabledProtocols(String[] strings) {
+    }
+
+    @Override
+    public SSLSession getSession() {
+        return new SSLSession() {
+            @Override
+            public byte[] getId() {
+               return String.valueOf(ssl).getBytes();
+            }
+
+            @Override
+            public SSLSessionContext getSessionContext() {
+                return null;
+            }
+
+            @Override
+            public long getCreationTime() {
+                return 0;
+            }
+
+            @Override
+            public long getLastAccessedTime() {
+                return 0;
+            }
+
+            @Override
+            public void invalidate() {
+
+            }
+
+            @Override
+            public boolean isValid() {
+                return false;
+            }
+
+            @Override
+            public void putValue(String s, Object o) {
+
+            }
+
+            @Override
+            public Object getValue(String s) {
+                return null;
+            }
+
+            @Override
+            public void removeValue(String s) {
+
+            }
+
+            @Override
+            public String[] getValueNames() {
+                return new String[0];
+            }
+
+            @Override
+            public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
+                return new Certificate[0];
+            }
+
+            @Override
+            public Certificate[] getLocalCertificates() {
+                return new Certificate[0];
+            }
+
+            @Override
+            public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
+                return new X509Certificate[0];
+            }
+
+            @Override
+            public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+                return null;
+            }
+
+            @Override
+            public Principal getLocalPrincipal() {
+                return null;
+            }
+
+            @Override
+            public String getCipherSuite() {
+                return cipher;
+            }
+
+            @Override
+            public String getProtocol() {
+                return protocol;
+            }
+
+            @Override
+            public String getPeerHost() {
+                return null;
+            }
+
+            @Override
+            public int getPeerPort() {
+                return 0;
+            }
+
+            @Override
+            public int getPacketBufferSize() {
+                return MAX_ENCRYPTED_PACKET;
+            }
+
+            @Override
+            public int getApplicationBufferSize() {
+                return MAX_PLAINTEXT_LENGTH;
+            }
+        };
+    }
+
+    /**
+     * This method causes the OpenSSL engine to accept connections
+     */
+    @Override
+    public synchronized void beginHandshake() throws SSLException {
+        if (engineClosed) throw ENGINE_IS_CLOSED;
+        if (!accepted) {
+            SSL.acceptConnectionOnSSL(ssl);
+            accepted = true;
+        } else {
+            throw RENEGOTIATION_NOT_SUPPORTED;
+        }
+    }
+
+    private SSLEngineResult.Status getEngineStatus() {
+        if (engineClosed)
+            return SSLEngineResult.Status.CLOSED;
+        return SSLEngineResult.Status.OK;
+    }
+
+    /**
+     * Return the handshake status of the SSL Engine.
+     */
+    @Override
+    public synchronized SSLEngineResult.HandshakeStatus getHandshakeStatus() {
+        if (!accepted || destroyed.get())
+            return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
+
+        // Check if we are in the initial handshake phase
+        if (!handshakeFinished) {
+            // There is pending data in the network BIO -- call wrap
+            if (SSL.pendingWrittenBytesInBIO(networkBIO) != 0)
+               return SSLEngineResult.HandshakeStatus.NEED_WRAP;
+
+            // No pending data to be sent to the peer
+            // Check to see if we have finished handshaking
+            if (SSL.isInInit(ssl) == 0) {
+                handshakeFinished = true;
+                cipher = SSL.getCipherForSSL(ssl);
+                protocol = SSL.getNextProtoNegotiated(ssl);
+                return SSLEngineResult.HandshakeStatus.FINISHED;
+            }
+
+            // No pending data and still handshaking
+            // Must be waiting on the peer to send more data
+            return SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
+        }
+
+        // Check if we are in the shutdown phase
+        if (engineClosed) {
+            // Waiting to send the close_notify message
+            if (SSL.pendingWrittenBytesInBIO(networkBIO) != 0)
+                return SSLEngineResult.HandshakeStatus.NEED_WRAP;
+
+            // Must be waiting to receive the close_notify message
+            return SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
+        }
+
+        return SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
+    }
+
+    @Override
+    public void setUseClientMode(boolean clientMode) {
+        if (clientMode)
+            throw new RuntimeException("Client mode is unsupported");
+    }
+
+    @Override
+    public boolean getUseClientMode() {
+        return false;
+    }
+
+    @Override
+    public void setNeedClientAuth(boolean b) {
+    }
+
+    @Override
+    public boolean getNeedClientAuth() {
+        return false;
+    }
+
+    @Override
+    public void setWantClientAuth(boolean b) {
+    }
+
+    @Override
+    public boolean getWantClientAuth() {
+        return false;
+    }
+
+    @Override
+    public void setEnableSessionCreation(boolean b) {
+    }
+
+    @Override
+    public boolean getEnableSessionCreation() {
+        return false;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        shutdown();
+        super.finalize();
+    }
+
+    public void setIdentifier(String identifier) {
+        this.identifier = identifier;
+    }
+
+    public String getIdentifier() {
+        return identifier;
+    }
+}
diff --git a/jni/java/org/apache/tomcat/jni/ssl/SSLConfiguration.java b/jni/java/org/apache/tomcat/jni/ssl/SSLConfiguration.java
new file mode 100644
index 0000000..1997d42
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/SSLConfiguration.java
@@ -0,0 +1,155 @@
+package org.apache.tomcat.jni.ssl;
+
+import java.util.Map;
+
+/**
+ * Encapsulates the configuration parameters necessary for the construction of a SSLContextHolder.
+ */
+public class SSLConfiguration {
+    /**
+     * Thrown when required fields have not been assigned in a SSLConfiguration.
+     */
+    public class IncompleteConfiguration extends Exception {
+        public IncompleteConfiguration(String message) {
+            super(message);
+        }
+    }
+
+    public static final String CERT_PATH = "ssl.cert_path";
+    public static final String KEY_PATH = "ssl.key_path";
+    public static final String CIPHER_SPEC = "ssl.cipher_spec";
+    public static final String KEY_PASSWORD = "ssl.key_password";
+    public static final String CA_PATH = "ssl.ca_path";
+    public static final String NEXT_PROTOS = "ssl.next_protos";
+
+    private String certPath = null;
+    private String keyPath = null;
+    private String cipherSpec = null;
+    private String keyPassword = null;
+    private String caPath = null;
+    private String nextProtos = null;
+
+    public SSLConfiguration(String certPath, String keyPath, String cipherSpec,
+                            String keyPassword, String caPath, String nextProtos)
+            throws IncompleteConfiguration {
+        this.certPath = certPath;
+        this.keyPath = keyPath;
+        this.cipherSpec = cipherSpec;
+        this.keyPassword = keyPassword;
+        this.caPath = caPath;
+        this.nextProtos = nextProtos;
+        verifyCorrectConstruction();
+    }
+
+    /**
+     * Construct a SSLConfiguration with data from the given Map.
+     *
+     * @param map The Map containing keys corresponding to the values of  CERT_PATH, KEY_PATH,
+     * CIPHER_SPEC, KEY_PASSWORD, and CA_PATH.
+     *
+     * @throws IncompleteConfiguration if required fields are not assigned.
+     */
+    public SSLConfiguration(Map map) throws IncompleteConfiguration {
+        assignFromMap(map);
+        verifyCorrectConstruction();
+    }
+
+    /**
+     * Assert all required fields are present, and set defaults for unassigned optional fields.
+     * @throws IncompleteConfiguration if required fields are not assigned
+     */
+    private void verifyCorrectConstruction() throws IncompleteConfiguration {
+        assertRequiredFieldsAssigned();
+        assignDefaultsToUnassignedOptionalFields();
+    }
+
+    /**
+     * Assign fields from the given Map.
+     *
+     * @param map the Map to assign from.
+     * @throws IncompleteConfiguration if required fields are not assigned
+     */
+    private void assignFromMap(Map map) throws IncompleteConfiguration {
+        // Assign required fields
+        this.certPath = (String)map.get(CERT_PATH);
+        this.keyPath = (String)map.get(KEY_PATH);
+        this.cipherSpec = (String)map.get(CIPHER_SPEC);
+
+        // Assign optional fields
+        this.keyPassword= (String)map.get(KEY_PASSWORD);
+        this.caPath = (String)map.get(CA_PATH);
+        this.nextProtos = (String)map.get(NEXT_PROTOS);
+    }
+
+    /**
+     * Assert that all required fields have been assigned.
+     *
+     * @throws IncompleteConfiguration if a required value is not set.
+     */
+    private void assertRequiredFieldsAssigned()
+            throws IncompleteConfiguration {
+        if (certPath == null || certPath.isEmpty())
+            throw new IncompleteConfiguration("certPath");
+
+        if (keyPath == null || keyPath.isEmpty())
+            throw new IncompleteConfiguration("keyPath");
+
+        if (cipherSpec == null || cipherSpec.isEmpty())
+            throw new IncompleteConfiguration("cipherSpec");
+    }
+
+    private void assignDefaultsToUnassignedOptionalFields() {
+        if (keyPassword == null) keyPassword = "";
+        if (caPath == null) caPath = "";
+        if (nextProtos == null) nextProtos = "";
+    }
+
+
+    public String getCertPath() {
+        return certPath;
+    }
+
+    public void setCertPath(String certPath) {
+        this.certPath = certPath;
+    }
+
+    public String getKeyPath() {
+        return keyPath;
+    }
+
+    public void setKeyPath(String keyPath) {
+        this.keyPath = keyPath;
+    }
+
+    public String getCipherSpec() {
+        return cipherSpec;
+    }
+
+    public void setCipherSpec(String cipherSpec) {
+        this.cipherSpec = cipherSpec;
+    }
+
+    public String getKeyPassword() {
+        return keyPassword;
+    }
+
+    public void setKeyPassword(String keyPassword) {
+        this.keyPassword = keyPassword;
+    }
+
+    public String getCaPath() {
+        return caPath;
+    }
+
+    public void setCaPath(String caPath) {
+        this.caPath = caPath;
+    }
+
+    public void setNextProtos(String nextProtos) {
+        this.nextProtos = nextProtos;
+    }
+
+    public String getNextProtos() {
+        return nextProtos;
+    }
+}
diff --git a/jni/java/org/apache/tomcat/jni/ssl/SSLContextHolder.java b/jni/java/org/apache/tomcat/jni/ssl/SSLContextHolder.java
new file mode 100644
index 0000000..d023598
--- /dev/null
+++ b/jni/java/org/apache/tomcat/jni/ssl/SSLContextHolder.java
@@ -0,0 +1,66 @@
+package org.apache.tomcat.jni.ssl;
+
+import org.apache.tomcat.jni.Pool;
+import org.apache.tomcat.jni.SSL;
+import org.apache.tomcat.jni.SSLContext;
+
+/**
+ * Encapsulates an OpenSSL SSL_CTX object.
+ */
+public class SSLContextHolder {
+    private long sslContext = 0L;
+
+    /**
+     * Create an SSLContext from the given SSLConfiguration
+     * @param sslConfiguration the SSLConfiguration
+     */
+    public SSLContextHolder(long pool, SSLConfiguration sslConfiguration) throws Exception {
+        synchronized (SSLContextHolder.class) {
+            sslContext = SSLContext.make(pool,
+                                         SSL.SSL_PROTOCOL_ALL,
+                                         SSL.SSL_MODE_SERVER);
+
+            /* TODO: ensure parity with Apache httpd in setting up the context. */
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_ALL);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_NO_SSLv2);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_SINGLE_DH_USE);
+            SSLContext.setOptions(sslContext, SSL.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
+
+            /* List the ciphers that the client is permitted to negotiate. */
+            SSLContext.setCipherSuite(sslContext, sslConfiguration.getCipherSpec());
+
+            /* Load server key and certificate */
+            if (!SSLContext.setCertificate(sslContext,
+                                           sslConfiguration.getCertPath(),
+                                           sslConfiguration.getKeyPath(),
+                                           sslConfiguration.getKeyPassword(),
+                                           SSL.SSL_AIDX_RSA)) {
+              throw new Exception("Failed to set up certificate '" + sslConfiguration.getCertPath() + "': " +
+                                  SSL.getLastError());
+            }
+
+            /* Set certificate verification policy. */
+            SSLContext.setVerify(sslContext, SSL.SSL_CVERIFY_NONE, 10);
+
+            /* Set next protocols for next protocol negotiation extension, if specified */
+            String nextProtos = sslConfiguration.getNextProtos();
+            if (nextProtos != null && nextProtos.length() > 0) {
+                SSLContext.setNextProtos(sslContext, nextProtos);
+            }
+
+            /* Load CA certificate, if specified */
+            String caPath = sslConfiguration.getCaPath();
+            if (caPath != null && caPath.length() > 0) {
+                if (!SSLContext.setCertificateChainFile(sslContext, caPath, false)) {
+                  throw new Exception("Failed to set up CA certificate '" + sslConfiguration.getCaPath() + "': " +
+                                      SSL.getLastError());
+                }
+            }
+        }
+    }
+
+    protected long getSslContext() {
+        return sslContext;
+    }
+}
diff --git a/jni/native/build/tcnative.m4 b/jni/native/build/tcnative.m4
index 47fa44b..de8e4ba 100644
--- a/jni/native/build/tcnative.m4
+++ b/jni/native/build/tcnative.m4
@@ -211,7 +211,7 @@ AC_DEFUN(
 
         JAVA_OS = ${tempval}
       ],
-      [   
+      [
         AC_MSG_CHECKING(os_type directory)
         JAVA_OS=NONE
         if test -f ${JAVA_HOME}/${JAVA_INC}/jni_md.h; then
@@ -280,129 +280,29 @@ AC_DEFUN(TCN_CHECK_SSL_TOOLKIT,[
 OPENSSL_WARNING=
 AC_MSG_CHECKING(for OpenSSL library)
 AC_ARG_WITH(ssl,
-[  --with-ssl[=PATH]   Build with OpenSSL [yes|no|path]],
-    use_openssl="$withval", use_openssl="auto")
-
-openssldirs="/usr /usr/local /usr/local/ssl /usr/pkg /usr/sfw"
-if test "$use_openssl" = "auto"
-then
-    for d in $openssldirs
-    do
-        if test -f $d/include/openssl/opensslv.h
-        then
-            use_openssl=$d
-            break
-        fi
-    done
-fi
-case "$use_openssl" in
-    no)
-        AC_MSG_RESULT(no)
-        TCN_OPENSSL_INC=""
-        USE_OPENSSL=""
-        ;;
-    auto)
-        TCN_OPENSSL_INC=""
-        USE_OPENSSL=""
-        AC_MSG_RESULT(not found)
-        ;;
-    *)
-        if test "$use_openssl" = "yes"
-        then
-            # User did not specify a path - guess it
-            for d in $openssldirs
-            do
-                if test -f $d/include/openssl/opensslv.h
-                then
-                    use_openssl=$d
-                    break
-                fi
-            done
-            if test "$use_openssl" = "yes"
-            then
-                AC_MSG_RESULT(not found)
-                AC_MSG_ERROR(
-[OpenSSL was not found in any of $openssldirs; use --with-ssl=/path])
-            fi
-        fi
-        USE_OPENSSL='-DOPENSSL'
-
-        if test "$use_openssl" = "/usr"
-        then
-            TCN_OPENSSL_INC=""
-            TCN_OPENSSL_LIBS="-lssl -lcrypto"
-        else
-            TCN_OPENSSL_INC="-I$use_openssl/include"
-            case $host in
-            *-solaris*)
-                TCN_OPENSSL_LIBS="-L$use_openssl/lib -R$use_openssl/lib -lssl -lcrypto"
-                ;;
-            *-hp-hpux*)
-                TCN_OPENSSL_LIBS="-L$use_openssl/lib -Wl,+b: -lssl -lcrypto"
-                ;;
-            *linux*)
-                TCN_OPENSSL_LIBS="-L$use_openssl/lib -Wl,-rpath,$use_openssl/lib -lssl -lcrypto"
-                ;;
-            *)
-                TCN_OPENSSL_LIBS="-L$use_openssl/lib -lssl -lcrypto"
-                ;;
-            esac
-        fi
-        AC_MSG_RESULT(using openssl from $use_openssl/lib and $use_openssl/include)
-
-        saved_cflags="$CFLAGS"
-        saved_libs="$LIBS"
-        CFLAGS="$CFLAGS $TCN_OPENSSL_INC"
-        LIBS="$LIBS $TCN_OPENSSL_LIBS"
-         
-AC_ARG_ENABLE(openssl-version-check,
-[AC_HELP_STRING([--enable-openssl-version-check],
-        [Check OpenSSL Version @<:@default=yes@:>@])])
-case "$enable_openssl_version_check" in
-yes|'')
-        AC_MSG_CHECKING(OpenSSL library version)
-        AC_TRY_RUN([
-#include <stdio.h>
-#include <openssl/opensslv.h>
-int main() {
-        if ((OPENSSL_VERSION_NUMBER >= 0x0090701fL &&
-         OPENSSL_VERSION_NUMBER < 0x00908000L) ||
-         OPENSSL_VERSION_NUMBER >= 0x0090801fL)
-            return (0);
-    printf("\n\nFound   OPENSSL_VERSION_NUMBER %#010x\n",
-        OPENSSL_VERSION_NUMBER);
-    printf("Require OPENSSL_VERSION_NUMBER 0x0090701f or greater (0.9.7a)\n"
-           "Require OPENSSL_VERSION_NUMBER 0x0090801f or greater (0.9.8a)\n\n");
-        return (1);
-}
-        ],
-        [AC_MSG_RESULT(ok)],
-        [AC_MSG_RESULT(not compatible)
-            OPENSSL_WARNING=yes
-        ],
-        [AC_MSG_RESULT(assuming target platform has compatible version)])
-;;
-no)
-    AC_MSG_RESULT(Skipped OpenSSL version check)
-;;
+[  --with-ssl[=PATH]   Build with OpenSSL [path]],
+    use_openssl="$withval", use_openssl="specify_a_path")
+
+TCN_OPENSSL_INC="-DOPENSSL -DHAVE_OPENSSL -I$use_openssl/include"
+case $host in
+*-solaris*)
+    TCN_OPENSSL_LIBS="$USE_OPENSSL -L$use_openssl/lib -L$use_openssl -R$use_openssl/lib -lssl -lcrypto"
+    ;;
+*-hp-hpux*)
+    TCN_OPENSSL_LIBS="$USE_OPENSSL -L$use_openssl/lib -L$use_openssl -Wl,+b: -lssl -lcrypto"
+    ;;
+*linux*)
+    TCN_OPENSSL_LIBS="$USE_OPENSSL -L$use_openssl/lib -lssl -lcrypto"
+    ;;
+*)
+    TCN_OPENSSL_LIBS="$USE_OPENSSL -L$use_openssl/lib -L$use_openssl -lssl -lcrypto"
+    ;;
 esac
 
-        AC_MSG_CHECKING(for OpenSSL DSA support)
-        if test -f $use_openssl/include/openssl/dsa.h
-        then
-            AC_DEFINE(HAVE_OPENSSL_DSA)
-            AC_MSG_RESULT(yes)
-        else
-            AC_MSG_RESULT(no)
-        fi
-        CFLAGS="$saved_cflags"
-        LIBS="$saved_libs"
-        ;;
-esac
-if test "x$USE_OPENSSL" != "x"
-then
-    APR_ADDTO(TCNATIVE_PRIV_INCLUDES, [$TCN_OPENSSL_INC])
-    APR_ADDTO(TCNATIVE_LDFLAGS, [$TCN_OPENSSL_LIBS])
-    APR_ADDTO(CFLAGS, [-DHAVE_OPENSSL])
-fi
+AC_MSG_RESULT(using openssl from $use_openssl/lib and $use_openssl/include)
+
+saved_cflags="$CFLAGS"
+saved_libs="$LIBS"
+CFLAGS="$CFLAGS $TCN_OPENSSL_INC"
+LIBS="$LIBS $TCN_OPENSSL_LIBS"
 ])
diff --git a/jni/native/include/ssl_private.h b/jni/native/include/ssl_private.h
index d2a2bfa..5b163a9 100644
--- a/jni/native/include/ssl_private.h
+++ b/jni/native/include/ssl_private.h
@@ -252,6 +252,9 @@ struct tcn_ssl_ctxt_t {
     int             verify_depth;
     int             verify_mode;
     tcn_pass_cb_t   *cb_data;
+
+    unsigned char   *next_proto_data;
+    unsigned int    next_proto_len;
 };
 
   
@@ -307,4 +310,5 @@ void        SSL_vhost_algo_id(const unsigned char *, unsigned char *, int);
 int         SSL_CTX_use_certificate_chain(SSL_CTX *, const char *, int);
 int         SSL_callback_SSL_verify(int, X509_STORE_CTX *);
 int         SSL_rand_seed(const char *file);
+int         SSL_callback_next_protos(SSL *, const unsigned char **, unsigned int *, void *);
 #endif /* SSL_PRIVATE_H */
diff --git a/jni/native/src/ssl.c b/jni/native/src/ssl.c
index 91e2a1a..3c1ddd2 100644
--- a/jni/native/src/ssl.c
+++ b/jni/native/src/ssl.c
@@ -926,7 +926,219 @@ TCN_IMPLEMENT_CALL(jboolean, SSL, hasOp)(TCN_STDARGS, jint op)
     return JNI_FALSE;
 }
 
+/*** Begin Twitter 1:1 API addition ***/
+TCN_IMPLEMENT_CALL(jint, SSL, getLastErrorNumber)(TCN_STDARGS)
+{
+    UNREFERENCED_STDARGS;
+    return ERR_get_error();
+}
+
+TCN_IMPLEMENT_CALL(jlong /* SSL * */, SSL, newSSL)(TCN_STDARGS,
+                                                   jlong ssl_ctx /* SSL_CTX * */) {
+    UNREFERENCED_STDARGS;
+    SSL_CTX *ctx = J2P(ssl_ctx, SSL_CTX *);
+
+    return P2J(SSL_new(ctx));
+}
+
+// How much did SSL write into this BIO?
+TCN_IMPLEMENT_CALL(jint /* nbytes */, SSL, pendingWrittenBytesInBIO)(TCN_STDARGS,
+                                                                     jlong bio /* BIO * */) {
+    UNREFERENCED_STDARGS;
+
+    return BIO_ctrl_pending(J2P(bio, BIO *));
+}
+
+// How much is available for reading in the given SSL struct?
+TCN_IMPLEMENT_CALL(jint, SSL, pendingReadableBytesInSSL)(TCN_STDARGS, jlong ssl /* SSL * */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_pending(J2P(ssl, SSL *));
+}
+
+// Write wlen bytes from wbuf into bio
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, writeToBIO)(TCN_STDARGS,
+                                                       jlong bio /* BIO * */,
+                                                       jlong wbuf /* char* */,
+                                                       jint wlen /* sizeof(wbuf) */) {
+    UNREFERENCED_STDARGS;
+
+    return BIO_write(J2P(bio, BIO *), J2P(wbuf, void *), wlen);
+
+}
+
+// Read up to rlen bytes from bio into rbuf
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, readFromBIO)(TCN_STDARGS,
+                                                        jlong bio /* BIO * */,
+                                                        jlong rbuf /* char * */,
+                                                        jint rlen /* sizeof(rbuf) - 1 */) {
+    UNREFERENCED_STDARGS;
+
+    return BIO_read(J2P(bio, BIO *), J2P(rbuf, void *), rlen);
+}
+
+// Write up to wlen bytes of application data to the ssl BIO (encrypt)
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, writeToSSL)(TCN_STDARGS,
+                                                       jlong ssl /* SSL * */,
+                                                       jlong wbuf /* char * */,
+                                                       jint wlen /* sizeof(wbuf) */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_write(J2P(ssl, SSL *), J2P(wbuf, void *), wlen);
+}
+
+// Read up to rlen bytes of application data from the given SSL BIO (decrypt)
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, readFromSSL)(TCN_STDARGS,
+                                                        jlong ssl /* SSL * */,
+                                                        jlong rbuf /* char * */,
+                                                        jint rlen /* sizeof(rbuf) - 1 */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_read(J2P(ssl, SSL *), J2P(rbuf, void *), rlen);
+}
+
+// Get the shutdown status of the engine
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, getShutdown)(TCN_STDARGS,
+                                                        jlong ssl /* SSL * */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_get_shutdown(J2P(ssl, SSL *));
+}
+
+// Called when the peer closes the connection
+TCN_IMPLEMENT_CALL(void, SSL, setShutdown)(TCN_STDARGS,
+                                           jlong ssl /* SSL * */,
+                                           jint mode) {
+    UNREFERENCED_STDARGS;
+
+    SSL_set_shutdown(J2P(ssl, SSL *), mode);
+}
+
+// Free the SSL * and its associated internal BIO
+TCN_IMPLEMENT_CALL(void, SSL, freeSSL)(TCN_STDARGS,
+                                       jlong ssl /* SSL * */) {
+    UNREFERENCED_STDARGS;
+
+    SSL_free(J2P(ssl, SSL *));
+}
+
+// Make a BIO pair (network and internal) for the provided SSL * and return the network BIO
+TCN_IMPLEMENT_CALL(jlong, SSL, makeNetworkBIO)(TCN_STDARGS,
+                                               jlong ssl /* SSL * */) {
+    SSL *ssl_ = J2P(ssl, SSL *);
+
+    UNREFERENCED(o);
+
+    if (ssl_ == NULL) {
+        tcn_ThrowException(e, "ssl is null");
+        goto fail;
+    }
+
+    BIO *internal_bio;
+    BIO *network_bio;
+
+    if (BIO_new_bio_pair(&internal_bio, 0, &network_bio, 0) != 1) {
+        tcn_ThrowException(e, "BIO_new_bio_pair failed");
+        goto fail;
+    }
+
+    SSL_set_bio(ssl_, internal_bio, internal_bio);
+
+    return P2J(network_bio);
+ fail:
+    return 0;
+}
+
+// Free a BIO * (typically, the network BIO)
+TCN_IMPLEMENT_CALL(void, SSL, freeBIO)(TCN_STDARGS,
+                                       jlong bio /* BIO * */) {
+    UNREFERENCED_STDARGS;
+
+    BIO *bio_ = J2P(bio, BIO *);
+    BIO_free(bio_);
+}
+
+// Send CLOSE_NOTIFY to peer
+TCN_IMPLEMENT_CALL(jint /* status */, SSL, shutdownSSL)(TCN_STDARGS,
+                                                        jlong ssl /* SSL * */) {
+    UNREFERENCED_STDARGS;
+
+    return SSL_shutdown(J2P(ssl, SSL *));
+}
+
+// Read which cipher was negotiated for the given SSL *.
+TCN_IMPLEMENT_CALL(jstring, SSL, getCipherForSSL)(TCN_STDARGS,
+                                                  jlong ssl /* SSL * */)
+{
+    UNREFERENCED_STDARGS;
+
+    return AJP_TO_JSTRING(SSL_get_cipher(J2P(ssl, SSL*)));
+}
+
+// Get the SSL_CTX * out of an tcn_ssl_ctxt_t * context struct.
+TCN_IMPLEMENT_CALL(jlong, SSL, getSSLCTXFromSSLContext)(TCN_STDARGS,
+                                                        jlong ctx /* tcn_ssl_ctxt_t * */) {
+    tcn_ssl_ctxt_t *ctx_ = J2P(ctx, tcn_ssl_ctxt_t *);
+    return P2J(ctx_->ctx);
+}
+
+// Is the handshake over yet?
+TCN_IMPLEMENT_CALL(jint, SSL, isInInit)(TCN_STDARGS,
+                                        jlong ssl /* SSL * */) {
+    SSL *ssl_ = J2P(ssl, SSL *);
+
+    UNREFERENCED(o);
+
+    if (ssl_ == NULL) {
+        tcn_ThrowException(e, "ssl is null");
+        return 0;
+    } else {
+        return SSL_in_init(ssl_);
+    }
+}
+
+// Put the SSL into its accept state (server)
+TCN_IMPLEMENT_CALL(void, SSL, acceptConnectionOnSSL)(TCN_STDARGS,
+                                                     jlong ssl /* SSL * */) {
+    SSL *ssl_ = J2P(ssl, SSL *);
+    if (ssl_ == NULL) {
+        tcn_ThrowException(e, "ssl is null");
+        return;
+    }
+
+    UNREFERENCED(o);
+
+    SSL_set_accept_state(ssl_);
+    // Start the client handshake
+    switch(SSL_do_handshake(ssl_)) {
+    case SSL_ERROR_SYSCALL:
+    case SSL_ERROR_SSL:
+        tcn_ThrowException(e, "SSL_do_handshake failed");
+        // TODO: extract error and add it to exception message
+    }
+}
+
+// Read which protocol was negotiated for the given SSL *.
+TCN_IMPLEMENT_CALL(jstring, SSL, getNextProtoNegotiated)(TCN_STDARGS,
+                                                         jlong ssl /* SSL * */) {
+    SSL *ssl_ = J2P(ssl, SSL *);
+    if (ssl_ == NULL) {
+        tcn_ThrowException(e, "ssl is null");
+        return;
+    }
+    const unsigned char *proto;
+    unsigned int proto_len;
+
+    UNREFERENCED(o);
+
+    SSL_get0_next_proto_negotiated(ssl_, &proto, &proto_len);
+    return tcn_new_stringn(e, proto, proto_len);
+}
+/*** End Twitter API Additions ***/
+
 #else
+#error OpenSSL is required!
+
 /* OpenSSL is not supported.
  * Create empty stubs.
  */
@@ -1037,4 +1249,138 @@ TCN_IMPLEMENT_CALL(jboolean, SSL, hasOp)(TCN_STDARGS, jint op)
     UNREFERENCED(op);
     return JNI_FALSE;
 }
+
+/*** Begin Twitter 1:1 API addition ***/
+TCN_IMPLEMENT_CALL(jlong, SSL, newSSL)(TCN_STDARGS, jlong ssl_ctx) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl_ctx);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, pendingWrittenBytesInBIO)(TCN_STDARGS, jlong bio) {
+  UNREFERENCED(o);
+  UNREFERENCED(bio);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, pendingReadableBytesInSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, writeToBIO)(TCN_STDARGS, jlong bio, jlong wbuf, jint wlen) {
+  UNREFERENCED(o);
+  UNREFERENCED(bio);
+  UNREFERENCED(wbuf);
+  UNREFERENCED(wlen);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, readFromBIO)(TCN_STDARGS, jlong bio, jlong rbuf, jint rlen) {
+  UNREFERENCED(o);
+  UNREFERENCED(bio);
+  UNREFERENCED(rbuf);
+  UNREFERENCED(rlen);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, writeToSSL)(TCN_STDARGS, jlong ssl, jlong wbuf, jint wlen) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  UNREFERENCED(wbuf);
+  UNREFERENCED(wlen);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, readFromSSL)(TCN_STDARGS, jlong ssl, jlong rbuf, jint rlen) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  UNREFERENCED(rbuf);
+  UNREFERENCED(rlen);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, getShutdown)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, setShutdown)(TCN_STDARGS, jlong ssl, jint mode) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  UNREFERENCED(mode);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, freeSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSL, makeNetworkBIO)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, freeBIO)(TCN_STDARGS, jlong bio) {
+  UNREFERENCED(o);
+  UNREFERENCED(bio);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, shutdownSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jstring, SSL, getCipherForSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return NULL;
+}
+
+TCN_IMPLEMENT_CALL(jlong, SSL, getSSLCTXFromSSLContext)(TCN_STDARGS, jlong ctx) {
+  UNREFERENCED(o);
+  UNREFERENCED(ctx);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(jint, SSL, isInInit)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return 0;
+}
+
+TCN_IMPLEMENT_CALL(void, SSL, acceptConnectionOnSSL)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+}
+
+TCN_IMPLEMENT_CALL(jstring, SSL, getNextProtoNegotiated)(TCN_STDARGS, jlong ssl) {
+  UNREFERENCED(o);
+  UNREFERENCED(ssl);
+  tcn_ThrowException(e, "Not implemented");
+  return NULL;
+}
+/*** End Twitter 1:1 API addition ***/
+
 #endif
diff --git a/jni/native/src/sslcontext.c b/jni/native/src/sslcontext.c
index 3aef357..cd4ef48 100644
--- a/jni/native/src/sslcontext.c
+++ b/jni/native/src/sslcontext.c
@@ -138,15 +138,34 @@ TCN_IMPLEMENT_CALL(jlong, SSLContext, make)(TCN_STDARGS, jlong pool,
      */
     SSL_CTX_set_options(c->ctx, SSL_OP_SINGLE_DH_USE);
 
+#ifdef SSL_OP_NO_COMPRESSION
+    SSL_CTX_set_options(c->ctx, SSL_OP_NO_COMPRESSION);
+#else
+#error "SSL_OP_NO_COMPRESSION not supported in your version of OpenSSL"
+#endif
+
 #ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
     /*
      * Disallow a session from being resumed during a renegotiation,
      * so that an acceptable cipher suite can be negotiated.
      */
     SSL_CTX_set_options(c->ctx, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
+#else
+#error "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION not supported in your version of OpenSSL"
+#endif
+
+#ifdef SSL_MODE_RELEASE_BUFFERS
+    /* Release idle buffers to the SSL_CTX free list */
+    SSL_CTX_set_mode(c->ctx, SSL_MODE_RELEASE_BUFFERS);
+#else
+#error "SSL_MODE_RELEASE_BUFFERS not supported in your version of OpenSSL"
 #endif
+
     /* Default session context id and cache size */
     SSL_CTX_sess_set_cache_size(c->ctx, SSL_DEFAULT_CACHE_SIZE);
+    /* Longer session timeout */
+    SSL_CTX_set_timeout(c->ctx, 14400);
+
     MD5((const unsigned char *)SSL_DEFAULT_VHOST_NAME,
         (unsigned long)(sizeof(SSL_DEFAULT_VHOST_NAME) - 1),
         &(c->context_id[0]));
@@ -585,6 +604,48 @@ cleanup:
     return rv;
 }
 
+TCN_IMPLEMENT_CALL(void, SSLContext, setNextProtos)(TCN_STDARGS, jlong ctx,
+                                                    jstring next_protos)
+{
+    int i, len, start = 0;
+    tcn_ssl_ctxt_t *c = J2P(ctx, tcn_ssl_ctxt_t *);
+    TCN_ALLOC_CSTRING(next_protos);
+
+    TCN_ASSERT(ctx != 0);
+    UNREFERENCED(o);
+
+    // Convert comma separated next_protos string to wire format
+    if (J2S(next_protos)) {
+        len = (int)strlen(J2S(next_protos));
+        if (len <= 65535) {
+        c->next_proto_len = (unsigned int)(strlen(J2S(next_protos)) + 1);
+            if ((c->next_proto_data = apr_palloc(c->pool, len + 1)) != NULL) {
+                c->next_proto_len = len + 1;
+                for (i = 0; i <= len; i++) {
+                    if (i == len || J2S(next_protos)[i] == ',') {
+                        if (i - start > 255) {
+                            c->next_proto_data = NULL;
+                            c->next_proto_len = 0;
+                            break;
+                        }
+                        (c->next_proto_data)[start] = i - start;
+                        start = i + 1;
+                    } else {
+                        (c->next_proto_data)[i+1] = J2S(next_protos)[i];
+                    }
+                }
+            }
+        }
+    }
+
+    // If conversion was successful set callback function
+    if (c->next_proto_data) {
+        SSL_CTX_set_next_protos_advertised_cb(c->ctx, SSL_callback_next_protos, (void *)c);
+    }
+
+    TCN_FREE_CSTRING(next_protos);
+}
+
 #else
 /* OpenSSL is not supported.
  * Create empty stubs.
@@ -721,4 +782,11 @@ TCN_IMPLEMENT_CALL(jboolean, SSLContext, setCertificate)(TCN_STDARGS, jlong ctx,
     return JNI_FALSE;
 }
 
+TCN_IMPLEMENT_CALL(void, SSLContext, setNextProtos)(TCN_STDARGS, jlong ctx,
+                                                            jstring next_protos)
+{
+    UNREFERENCED_STDARGS;
+    UNREFERENCED(ctx);
+    UNREFERENCED(next_protos);
+}
 #endif
diff --git a/jni/native/src/sslutils.c b/jni/native/src/sslutils.c
index 683283c..f4d5572 100644
--- a/jni/native/src/sslutils.c
+++ b/jni/native/src/sslutils.c
@@ -708,5 +708,16 @@ void SSL_callback_handshake(const SSL *ssl, int where, int rc)
     }
 
 }
- 
+
+int SSL_callback_next_protos(SSL *ssl, const unsigned char **data,
+                             unsigned int *len, void *arg)
+{
+    tcn_ssl_ctxt_t *ssl_ctxt = arg;
+
+    *data = ssl_ctxt->next_proto_data;
+    *len = ssl_ctxt->next_proto_len;
+
+    return SSL_TLSEXT_ERR_OK;
+}
+
 #endif
